<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Components/HealthComponent.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Components/HealthComponent.cpp" />
              <option name="updatedContent" value="#include &quot;Components/HealthComponent.h&quot;&#10;#include &quot;Data/VoxelEntityData.h&quot;&#10;&#10;void UHealthComponent::OnEntityAdded(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {&#10;  TotalHealth += Data.GetHealth();&#10;}&#10;&#10;void UHealthComponent::OnEntityRemoved(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {&#10;  TotalHealth -= Data.GetHealth();&#10;  TotalHealth = FMath::Max(0.0f, TotalHealth);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Components/TargetComponent.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Components/TargetComponent.cpp" />
              <option name="originalContent" value="#include &quot;Components/TargetComponent.h&quot;&#10;&#10;#include &quot;EntityChunk.h&quot;&#10;#include &quot;Kismet/GameplayStatics.h&quot;&#10;&#10;void UTargetComponent::Tick(const float DeltaTime) {&#10;  Super::Tick(DeltaTime);&#10;  TArray&lt;AActor *&gt; Actors;&#10;  UGameplayStatics::GetAllActorsOfClass(GetWorld(), TargetClass, Actors);&#10;&#10;  TArray&lt;TPair&lt;float, TObjectPtr&lt;AActor&gt;&gt;&gt; Priorities;&#10;  for (AActor *Actor : Actors) {&#10;  }&#10;}&#10;&#10;float UTargetComponent::GetTargetPriority(&#10;    const TObjectPtr&lt;AActor&gt; TargetCandidate) {&#10;  return FVector::Dist(TargetCandidate-&gt;GetActorLocation(),&#10;                       OwnerChunk-&gt;CenterOfMass);&#10;}" />
              <option name="updatedContent" value="#include &quot;Components/TargetComponent.h&quot;&#10;&#10;#include &quot;EntityChunk.h&quot;&#10;#include &quot;Kismet/GameplayStatics.h&quot;&#10;&#10;void UTargetComponent::Tick(const float DeltaTime) {&#10;  Super::Tick(DeltaTime);&#10;  &#10;  if (!TargetClass || !OwnerChunk) {&#10;    return;&#10;  }&#10;&#10;  UpdateTargets();&#10;}&#10;&#10;void UTargetComponent::UpdateTargets() {&#10;  // Remove invalid targets&#10;  Targets.RemoveAll([this](const TObjectPtr&lt;AActor&gt;&amp; Target) {&#10;    return !IsValidTarget(Target.Get());&#10;  });&#10;&#10;  // If we have enough targets, return early&#10;  if (Targets.Num() &gt;= TargetCount) {&#10;    return;&#10;  }&#10;&#10;  // Find new targets&#10;  TArray&lt;AActor*&gt; Actors;&#10;  UGameplayStatics::GetAllActorsOfClass(GetWorld(), TargetClass, Actors);&#10;&#10;  TArray&lt;TPair&lt;float, TObjectPtr&lt;AActor&gt;&gt;&gt; Priorities;&#10;  for (AActor* Actor : Actors) {&#10;    if (IsValidTarget(Actor) &amp;&amp; !Targets.Contains(Actor)) {&#10;      float Priority = GetTargetPriority(Actor);&#10;      Priorities.Add(TPair&lt;float, TObjectPtr&lt;AActor&gt;&gt;(Priority, Actor));&#10;    }&#10;  }&#10;&#10;  // Sort by priority (lower distance = higher priority)&#10;  Priorities.Sort([](const TPair&lt;float, TObjectPtr&lt;AActor&gt;&gt;&amp; A, const TPair&lt;float, TObjectPtr&lt;AActor&gt;&gt;&amp; B) {&#10;    return A.Key &lt; B.Key;&#10;  });&#10;&#10;  // Add targets up to TargetCount&#10;  int32 TargetsToAdd = TargetCount - Targets.Num();&#10;  for (int32 i = 0; i &lt; FMath::Min(TargetsToAdd, Priorities.Num()); ++i) {&#10;    Targets.Add(Priorities[i].Value);&#10;  }&#10;}&#10;&#10;bool UTargetComponent::IsValidTarget(AActor* Actor) const {&#10;  return Actor &amp;&amp; IsValid(Actor) &amp;&amp; Actor-&gt;IsA(TargetClass);&#10;}&#10;&#10;float UTargetComponent::GetTargetPriority(const TObjectPtr&lt;AActor&gt; TargetCandidate) {&#10;  if (!TargetCandidate || !OwnerChunk) {&#10;    return MAX_FLT;&#10;  }&#10;&#10;  return FVector::Dist(TargetCandidate-&gt;GetActorLocation(), OwnerChunk-&gt;GetCenterOfMass());&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Entity/Entity.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Entity/Entity.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Entity/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Entity/EntityChunk.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/EntityChunk.cpp" />
              <option name="originalContent" value="#include &quot;EntityChunk.h&quot;&#10;&#10;void UEntityChunk::Tick(float DeltaTime) {}&#10;&#10;void UEntityChunk::AddEntity(const FIntVector &amp;VoxelCoord) {&#10;  ManagedVoxels.Add(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::RemoveEntity(const FIntVector &amp;VoxelCoord) {&#10;  ManagedVoxels.Remove(VoxelCoord);&#10;}&#10;&#10;bool UEntityChunk::IsEmpty() const { return ManagedVoxels.IsEmpty(); }&#10;&#10;void UEntityChunk::OnEntityDataModified(const FIntVector &amp;VoxelCoord) {}&#10;" />
              <option name="updatedContent" value="#include &quot;EntityChunk.h&quot;&#10;#include &quot;EntityChunkComponent.h&quot;&#10;&#10;void UEntityChunk::Tick(float DeltaTime) {&#10;  for (UEntityChunkComponent* Component : Components) {&#10;    if (Component) {&#10;      Component-&gt;Tick(DeltaTime);&#10;    }&#10;  }&#10;}&#10;&#10;void UEntityChunk::AddEntity(const FIntVector &amp;VoxelCoord, const FVoxelEntityData&amp; EntityData) {&#10;  ManagedVoxels.Add(VoxelCoord);&#10;  &#10;  for (UEntityChunkComponent* Component : Components) {&#10;    if (Component) {&#10;      Component-&gt;OnEntityAdded(VoxelCoord, EntityData);&#10;    }&#10;  }&#10;}&#10;&#10;void UEntityChunk::RemoveEntity(const FIntVector &amp;VoxelCoord, const FVoxelEntityData&amp; EntityData) {&#10;  ManagedVoxels.Remove(VoxelCoord);&#10;  &#10;  for (UEntityChunkComponent* Component : Components) {&#10;    if (Component) {&#10;      Component-&gt;OnEntityRemoved(VoxelCoord, EntityData);&#10;    }&#10;  }&#10;}&#10;&#10;bool UEntityChunk::IsEmpty() const { &#10;  return ManagedVoxels.IsEmpty(); &#10;}&#10;&#10;void UEntityChunk::OnEntityDataModified(const FIntVector &amp;VoxelCoord, const FVoxelEntityData&amp; EntityData) {&#10;  for (UEntityChunkComponent* Component : Components) {&#10;    if (Component) {&#10;      Component-&gt;OnEntityModified(VoxelCoord, EntityData);&#10;    }&#10;  }&#10;}&#10;&#10;void UEntityChunk::AddComponent(UEntityChunkComponent* Component) {&#10;  if (Component) {&#10;    Component-&gt;OwnerChunk = this;&#10;    Components.Add(Component);&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/EntityChunkComponent.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/EntityChunkComponent.cpp" />
              <option name="updatedContent" value="#include &quot;EntityChunkComponent.h&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Logic/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Logic/EntityChunk.cpp" />
              <option name="updatedContent" value="#include &quot;Logic/EntityChunk.h&quot;&#10;#include &quot;Managers/EntityManager.h&quot;&#10;&#10;void UEntityChunk::Initialize(UEntityManager* InManager)&#10;{&#10;&#9;EntityManager = InManager;&#10;}&#10;&#10;void UEntityChunk::Tick(float DeltaTime)&#10;{&#10;&#9;// 이 청크에 대한 로직을 매 프레임 실행합니다. (예: 특정 액터 이동, 상태 변화 등)&#10;}&#10;&#10;void UEntityChunk::AddVoxel(const FIntVector&amp; VoxelCoord)&#10;{&#10;&#9;ManagedVoxels.Add(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::RemoveVoxel(const FIntVector&amp; VoxelCoord)&#10;{&#10;&#9;ManagedVoxels.Remove(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::MergeWith(UEntityChunk* OtherChunk)&#10;{&#10;&#9;if (!OtherChunk || OtherChunk == this) return;&#10;&#10;&#9;// 다른 청크의 복셀들을 현재 청크로 이동시킵니다.&#10;&#9;ManagedVoxels.Append(OtherChunk-&gt;GetVoxels());&#10;&#9;&#10;&#9;// 이동된 복셀들이 이제 현재 청크를 가리키도록 맵을 업데이트합니다.&#10;&#9;UpdateVoxelMap();&#10;}&#10;&#10;const TSet&lt;FIntVector&gt;&amp; UEntityChunk::GetVoxels() const&#10;{&#10;&#9;return ManagedVoxels;&#10;}&#10;&#10;bool UEntityChunk::IsEmpty() const&#10;{&#10;&#9;return ManagedVoxels.IsEmpty();&#10;}&#10;&#10;void UEntityChunk::UpdateVoxelMap()&#10;{&#10;&#9;if (EntityManager)&#10;&#9;{&#10;&#9;&#9;for (const FIntVector&amp; VoxelCoord : ManagedVoxels)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;EntityManager-&gt;UpdateVoxelChunkMapping(VoxelCoord, this);&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Managers/DataManager.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Managers/DataManager.cpp" />
              <option name="originalContent" value="#include &quot;Managers/DataManager.h&quot;&#10;&#10;#include &quot;Actors/VoxelChunkActor.h&quot;&#10;#include &quot;Actors/VoxelWorldActor.h&quot;&#10;#include &quot;DataAssets/VoxelBaseDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;Managers/DebugManager.h&quot;&#10;#include &quot;Managers/EntityManager.h&quot;&#10;#include &quot;Managers/MeshManager.h&quot;&#10;&#10;void UDataManager::Initialize(&#10;    const FIntVector &amp;InWorldSizeInChunks, const int32 InChunkSize,&#10;    const int32 InVoxelSize,&#10;    const TSubclassOf&lt;AVoxelChunkActor&gt; &amp;InVoxelChunkActor) {&#10;  const AVoxelWorldActor *VoxelWorld = Cast&lt;AVoxelWorldActor&gt;(GetOuter());&#10;  DebugManager = VoxelWorld-&gt;GetDebugManager();&#10;  MeshManager = VoxelWorld-&gt;GetMeshManager();&#10;  EntityManager = VoxelWorld-&gt;GetEntityManager();&#10;  WorldSizeInChunks = InWorldSizeInChunks;&#10;  ChunkSize = InChunkSize;&#10;  VoxelSize = InVoxelSize;&#10;  ChunkVolume = ChunkSize * ChunkSize * ChunkSize;&#10;  VoxelChunk = InVoxelChunkActor;&#10;&#10;  VoxelChunks.Empty();&#10;}&#10;&#10;void UDataManager::LoadVoxelChunk(const FIntVector &amp;ChunkCoord) {&#10;  if (VoxelChunks.Contains(ChunkCoord)) {&#10;    return;&#10;  }&#10;&#10;  if (!VoxelChunk) {&#10;    return;&#10;  }&#10;&#10;  FVoxelChunk NewChunk(ChunkSize);&#10;&#10;  UWorld *World = GetWorld();&#10;  if (!World) {&#10;    return;&#10;  }&#10;&#10;  FActorSpawnParameters SpawnParams;&#10;  SpawnParams.Owner = Cast&lt;AActor&gt;(GetOuter());&#10;&#10;  AVoxelChunkActor *NewVoxelChunk = World-&gt;SpawnActor&lt;AVoxelChunkActor&gt;(&#10;      VoxelChunk, GlobalToWorldCoord(ChunkToGlobalCoord(ChunkCoord)),&#10;      FRotator::ZeroRotator, SpawnParams);&#10;&#10;  if (NewVoxelChunk) {&#10;    if (AActor *Owner = Cast&lt;AActor&gt;(GetOuter())) {&#10;      NewVoxelChunk-&gt;AttachToActor(&#10;          Owner, FAttachmentTransformRules::KeepWorldTransform);&#10;    }&#10;    NewVoxelChunk-&gt;Initialize(ChunkCoord);&#10;    NewChunk.VoxelChunkActor = NewVoxelChunk;&#10;&#10;    VoxelChunks.Add(ChunkCoord, MoveTemp(NewChunk));&#10;  }&#10;}&#10;&#10;void UDataManager::UnloadVoxelChunk(const FIntVector &amp;ChunkCoord) {&#10;  if (const FVoxelChunk *Chunk = VoxelChunks.Find(ChunkCoord)) {&#10;    if (Chunk-&gt;VoxelChunkActor) {&#10;      Chunk-&gt;VoxelChunkActor-&gt;Destroy();&#10;    }&#10;    VoxelChunks.Remove(ChunkCoord);&#10;  }&#10;}&#10;&#10;const FVoxelBaseData *&#10;UDataManager::GetVoxelData(const FIntVector &amp;GlobalCoord) const {&#10;  if (const FVoxelChunk *Chunk =&#10;          VoxelChunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    return Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord));&#10;  }&#10;  return nullptr;&#10;}&#10;&#10;void UDataManager::ModifyVoxelData(&#10;    const FIntVector &amp;GlobalCoord,&#10;    const TFunction&lt;void(FVoxelBaseData *)&gt; &amp;Modifier, const bool bAutoDebug) {&#10;  if (const FVoxelChunk *Chunk =&#10;          VoxelChunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    Modifier(Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord)));&#10;&#10;    if (EntityManager) {&#10;      EntityManager-&gt;OnEntityDataModified(GlobalCoord);&#10;    }&#10;&#10;    if (DebugManager &amp;&amp; bAutoDebug) {&#10;      DebugManager-&gt;SetDebugVoxel(GlobalCoord);&#10;    }&#10;&#10;    if (MeshManager) {&#10;      MeshManager-&gt;SetDirtyChunk(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;void UDataManager::SetVoxelData(const FIntVector &amp;GlobalCoord,&#10;                                FVoxelBaseData *NewVoxelData,&#10;                                const bool bAutoDebug) {&#10;  if (const FVoxelChunk *Chunk =&#10;          VoxelChunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    const FVoxelBaseData *OldData =&#10;        Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord));&#10;&#10;    Chunk-&gt;SetVoxelData(GlobalCoordToIndex(GlobalCoord), NewVoxelData);&#10;&#10;    if (EntityManager) {&#10;      if (const FVoxelEntityData *NewEntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(NewVoxelData)) {&#10;        EntityManager-&gt;OnEntityDataCreated(GlobalCoord, NewEntityData);&#10;      } else if (FVoxelEntityData::IsEntity(OldData)) {&#10;        EntityManager-&gt;OnEntityDataDestroyed(GlobalCoord);&#10;      }&#10;    }&#10;&#10;    delete OldData;&#10;&#10;    if (DebugManager &amp;&amp; bAutoDebug) {&#10;      DebugManager-&gt;SetDebugVoxel(GlobalCoord);&#10;    }&#10;&#10;    if (MeshManager) {&#10;      MeshManager-&gt;SetDirtyChunk(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;bool UDataManager::IsVoxelChunkLoaded(const FIntVector &amp;ChunkCoord) const {&#10;  return VoxelChunks.Contains(ChunkCoord);&#10;}&#10;&#10;FVoxelChunk *UDataManager::GetVoxelChunk(const FIntVector &amp;ChunkCoord) {&#10;  return VoxelChunks.Find(ChunkCoord);&#10;}&#10;&#10;FIntVector&#10;UDataManager::GlobalToChunkCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return FIntVector(&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.X) / ChunkSize),&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.Y) / ChunkSize),&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.Z) / ChunkSize));&#10;}&#10;&#10;FIntVector&#10;UDataManager::ChunkToGlobalCoord(const FIntVector &amp;ChunkCoord) const {&#10;  return ChunkCoord * ChunkSize;&#10;}&#10;&#10;FIntVector&#10;UDataManager::GlobalToLocalCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return GlobalCoord % ChunkSize;&#10;}&#10;&#10;int32 UDataManager::GlobalCoordToIndex(const FIntVector &amp;GlobalCoord) const {&#10;  return LocalCoordToIndex(GlobalToLocalCoord(GlobalCoord));&#10;}&#10;&#10;FIntVector&#10;UDataManager::LocalToGlobalCoord(const FIntVector &amp;LocalCoord,&#10;                                 const FIntVector &amp;ChunkCoord) const {&#10;  return ChunkToGlobalCoord(ChunkCoord) + LocalCoord;&#10;}&#10;&#10;FIntVector UDataManager::WorldToGlobalCoord(const FVector &amp;WorldCoord) const {&#10;  return FIntVector(FMath::RoundToInt(WorldCoord.X / VoxelSize),&#10;                    FMath::RoundToInt(WorldCoord.Y / VoxelSize),&#10;                    FMath::RoundToInt(WorldCoord.Z / VoxelSize));&#10;}&#10;&#10;FVector UDataManager::GlobalToWorldCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return FVector(GlobalCoord) * VoxelSize;&#10;}&#10;&#10;int32 UDataManager::LocalCoordToIndex(const FIntVector &amp;LocalCoord) const {&#10;  return LocalCoord.X + LocalCoord.Y * ChunkSize +&#10;         LocalCoord.Z * ChunkSize * ChunkSize;&#10;}" />
              <option name="updatedContent" value="#include &quot;Managers/DataManager.h&quot;&#10;&#10;#include &quot;Actors/VoxelChunkActor.h&quot;&#10;#include &quot;Actors/VoxelWorldActor.h&quot;&#10;#include &quot;DataAssets/VoxelBaseDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;Managers/DebugManager.h&quot;&#10;#include &quot;Managers/EntityManager.h&quot;&#10;#include &quot;Managers/MeshManager.h&quot;&#10;&#10;void UDataManager::Initialize(&#10;    const FIntVector &amp;InWorldSizeInChunks, const int32 InChunkSize,&#10;    const int32 InVoxelSize,&#10;    const TSubclassOf&lt;AVoxelChunkActor&gt; &amp;InVoxelChunkActor) {&#10;  const AVoxelWorldActor *VoxelWorld = Cast&lt;AVoxelWorldActor&gt;(GetOuter());&#10;  DebugManager = VoxelWorld-&gt;GetDebugManager();&#10;  MeshManager = VoxelWorld-&gt;GetMeshManager();&#10;  EntityManager = VoxelWorld-&gt;GetEntityManager();&#10;  WorldSizeInChunks = InWorldSizeInChunks;&#10;  ChunkSize = InChunkSize;&#10;  VoxelSize = InVoxelSize;&#10;  ChunkVolume = ChunkSize * ChunkSize * ChunkSize;&#10;  VoxelChunk = InVoxelChunkActor;&#10;&#10;  VoxelChunks.Empty();&#10;}&#10;&#10;void UDataManager::LoadVoxelChunk(const FIntVector &amp;ChunkCoord) {&#10;  if (VoxelChunks.Contains(ChunkCoord)) {&#10;    return;&#10;  }&#10;&#10;  if (!VoxelChunk) {&#10;    return;&#10;  }&#10;&#10;  FVoxelChunk NewChunk(ChunkSize);&#10;&#10;  UWorld *World = GetWorld();&#10;  if (!World) {&#10;    return;&#10;  }&#10;&#10;  FActorSpawnParameters SpawnParams;&#10;  SpawnParams.Owner = Cast&lt;AActor&gt;(GetOuter());&#10;&#10;  AVoxelChunkActor *NewVoxelChunk = World-&gt;SpawnActor&lt;AVoxelChunkActor&gt;(&#10;      VoxelChunk, GlobalToWorldCoord(ChunkToGlobalCoord(ChunkCoord)),&#10;      FRotator::ZeroRotator, SpawnParams);&#10;&#10;  if (NewVoxelChunk) {&#10;    if (AActor *Owner = Cast&lt;AActor&gt;(GetOuter())) {&#10;      NewVoxelChunk-&gt;AttachToActor(&#10;          Owner, FAttachmentTransformRules::KeepWorldTransform);&#10;    }&#10;    NewVoxelChunk-&gt;Initialize(ChunkCoord);&#10;    NewChunk.VoxelChunkActor = NewVoxelChunk;&#10;&#10;    VoxelChunks.Add(ChunkCoord, MoveTemp(NewChunk));&#10;  }&#10;}&#10;&#10;void UDataManager::UnloadVoxelChunk(const FIntVector &amp;ChunkCoord) {&#10;  if (const FVoxelChunk *Chunk = VoxelChunks.Find(ChunkCoord)) {&#10;    if (Chunk-&gt;VoxelChunkActor) {&#10;      Chunk-&gt;VoxelChunkActor-&gt;Destroy();&#10;    }&#10;    VoxelChunks.Remove(ChunkCoord);&#10;  }&#10;}&#10;&#10;const FVoxelBaseData *&#10;UDataManager::GetVoxelData(const FIntVector &amp;GlobalCoord) const {&#10;  if (const FVoxelChunk *Chunk =&#10;          VoxelChunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    return Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord));&#10;  }&#10;  return nullptr;&#10;}&#10;&#10;void UDataManager::ModifyVoxelData(&#10;    const FIntVector &amp;GlobalCoord,&#10;    const TFunction&lt;void(FVoxelBaseData *)&gt; &amp;Modifier, const bool bAutoDebug) {&#10;  if (const FVoxelChunk *Chunk =&#10;          VoxelChunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    Modifier(Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord)));&#10;&#10;    if (EntityManager) {&#10;      if (const FVoxelEntityData *EntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord)))) {&#10;        EntityManager-&gt;OnEntityDataModified(GlobalCoord, EntityData);&#10;      }&#10;    }&#10;&#10;    if (DebugManager &amp;&amp; bAutoDebug) {&#10;      DebugManager-&gt;SetDebugVoxel(GlobalCoord);&#10;    }&#10;&#10;    if (MeshManager) {&#10;      MeshManager-&gt;SetDirtyChunk(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;void UDataManager::SetVoxelData(const FIntVector &amp;GlobalCoord,&#10;                                FVoxelBaseData *NewVoxelData,&#10;                                const bool bAutoDebug) {&#10;  if (const FVoxelChunk *Chunk =&#10;          VoxelChunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    const FVoxelBaseData *OldData =&#10;        Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord));&#10;&#10;    Chunk-&gt;SetVoxelData(GlobalCoordToIndex(GlobalCoord), NewVoxelData);&#10;&#10;    if (EntityManager) {&#10;      if (const FVoxelEntityData *NewEntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(NewVoxelData)) {&#10;        EntityManager-&gt;OnEntityDataCreated(GlobalCoord, NewEntityData);&#10;      } else if (const FVoxelEntityData *OldEntityData =&#10;                     dynamic_cast&lt;const FVoxelEntityData *&gt;(OldData)) {&#10;        EntityManager-&gt;OnEntityDataDestroyed(GlobalCoord, OldEntityData);&#10;      }&#10;    }&#10;&#10;    delete OldData;&#10;&#10;    if (DebugManager &amp;&amp; bAutoDebug) {&#10;      DebugManager-&gt;SetDebugVoxel(GlobalCoord);&#10;    }&#10;&#10;    if (MeshManager) {&#10;      MeshManager-&gt;SetDirtyChunk(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;bool UDataManager::IsVoxelChunkLoaded(const FIntVector &amp;ChunkCoord) const {&#10;  return VoxelChunks.Contains(ChunkCoord);&#10;}&#10;&#10;FVoxelChunk *UDataManager::GetVoxelChunk(const FIntVector &amp;ChunkCoord) {&#10;  return VoxelChunks.Find(ChunkCoord);&#10;}&#10;&#10;FIntVector&#10;UDataManager::GlobalToChunkCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return FIntVector(&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.X) / ChunkSize),&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.Y) / ChunkSize),&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.Z) / ChunkSize));&#10;}&#10;&#10;FIntVector&#10;UDataManager::ChunkToGlobalCoord(const FIntVector &amp;ChunkCoord) const {&#10;  return ChunkCoord * ChunkSize;&#10;}&#10;&#10;FIntVector&#10;UDataManager::GlobalToLocalCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return GlobalCoord % ChunkSize;&#10;}&#10;&#10;int32 UDataManager::GlobalCoordToIndex(const FIntVector &amp;GlobalCoord) const {&#10;  return LocalCoordToIndex(GlobalToLocalCoord(GlobalCoord));&#10;}&#10;&#10;FIntVector&#10;UDataManager::LocalToGlobalCoord(const FIntVector &amp;LocalCoord,&#10;                                 const FIntVector &amp;ChunkCoord) const {&#10;  return ChunkToGlobalCoord(ChunkCoord) + LocalCoord;&#10;}&#10;&#10;FIntVector UDataManager::WorldToGlobalCoord(const FVector &amp;WorldCoord) const {&#10;  return FIntVector(FMath::RoundToInt(WorldCoord.X / VoxelSize),&#10;                    FMath::RoundToInt(WorldCoord.Y / VoxelSize),&#10;                    FMath::RoundToInt(WorldCoord.Z / VoxelSize));&#10;}&#10;&#10;FVector UDataManager::GlobalToWorldCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return FVector(GlobalCoord) * VoxelSize;&#10;}&#10;&#10;int32 UDataManager::LocalCoordToIndex(const FIntVector &amp;LocalCoord) const {&#10;  return LocalCoord.X + LocalCoord.Y * ChunkSize +&#10;         LocalCoord.Z * ChunkSize * ChunkSize;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Managers/EntityManager.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Managers/EntityManager.cpp" />
              <option name="originalContent" value="#include &quot;Managers/EntityManager.h&quot;&#10;&#10;#include &quot;Actors/VoxelWorldActor.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;EntityChunk.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;&#10;void UEntityManager::Initialize() {&#10;  if (const TObjectPtr&lt;AVoxelWorldActor&gt; VoxelWorld =&#10;          Cast&lt;AVoxelWorldActor&gt;(GetOuter())) {&#10;    DataManager = VoxelWorld-&gt;GetDataManager();&#10;  }&#10;}&#10;&#10;void UEntityManager::Tick(const float DeltaTime) {&#10;  for (const TObjectPtr Chunk : EntityChunks) {&#10;    if (Chunk) {&#10;      Chunk-&gt;Tick(DeltaTime);&#10;    }&#10;  }&#10;}&#10;&#10;void UEntityManager::OnEntityDataCreated(const FIntVector &amp;GlobalCoord,&#10;                                         const FVoxelEntityData *EntityData) {&#10;  if (EntityToChunk.Contains(GlobalCoord) || !EntityData) {&#10;    return;&#10;  }&#10;&#10;  TSet&lt;TObjectPtr&lt;UEntityChunk&gt;&gt; ChunkableChunks;&#10;&#10;  for (const FIntVector &amp;NeighborOffset : NeighborOffsets) {&#10;    if (const TObjectPtr&lt;UEntityChunk&gt; *FoundChunk =&#10;            EntityToChunk.Find(GlobalCoord + NeighborOffset)) {&#10;      if (const FVoxelEntityData *NeighborEntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(GlobalCoord + NeighborOffset))) {&#10;        if (EntityData-&gt;IsChunkableWith(NeighborEntityData)) {&#10;          ChunkableChunks.Add(*FoundChunk);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  TObjectPtr&lt;UEntityChunk&gt; TargetChunk;&#10;&#10;  if (ChunkableChunks.IsEmpty()) {&#10;    TargetChunk = CreateEntityChunk(EntityData);&#10;  } else {&#10;    TargetChunk = ChunkableChunks.Array()[0];&#10;    ChunkableChunks.Remove(TargetChunk);&#10;&#10;    for (UEntityChunk *ChunkToMerge : ChunkableChunks) {&#10;      TArray&lt;FIntVector&gt; VoxelsToMove =&#10;          ChunkToMerge-&gt;GetManagedVoxels().Array();&#10;&#10;      for (const FIntVector &amp;VoxelCoord : VoxelsToMove) {&#10;        if (const FVoxelEntityData *VoxelEntityData =&#10;                dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                    DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;          ChunkToMerge-&gt;RemoveEntity(VoxelCoord, *VoxelEntityData);&#10;          TargetChunk-&gt;AddEntity(VoxelCoord, *VoxelEntityData);&#10;          EntityToChunk[VoxelCoord] = TargetChunk;&#10;        }&#10;      }&#10;&#10;      EntityChunks.Remove(ChunkToMerge);&#10;    }&#10;  }&#10;&#10;  TargetChunk-&gt;AddEntity(GlobalCoord, *EntityData);&#10;  EntityToChunk.Add(GlobalCoord, TargetChunk);&#10;}&#10;&#10;void UEntityManager::OnEntityDataDestroyed(const FIntVector &amp;GlobalCoord) {&#10;  if (!EntityToChunk.Contains(GlobalCoord)) {&#10;    return;&#10;  }&#10;&#10;  UEntityChunk *OwningChunk = EntityToChunk.FindAndRemoveChecked(GlobalCoord);&#10;&#10;  if (const FVoxelEntityData *EntityData =&#10;          dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;              DataManager-&gt;GetVoxelData(GlobalCoord))) {&#10;    OwningChunk-&gt;RemoveEntity(GlobalCoord, *EntityData);&#10;  }&#10;&#10;  if (OwningChunk-&gt;IsEmpty()) {&#10;    EntityChunks.Remove(OwningChunk);&#10;  } else {&#10;    UpdateEntityChunk(OwningChunk);&#10;  }&#10;}&#10;&#10;void UEntityManager::OnEntityDataModified(const FIntVector &amp;GlobalCoord) {&#10;  if (const TObjectPtr&lt;UEntityChunk&gt; *FoundChunk =&#10;          EntityToChunk.Find(GlobalCoord)) {&#10;    if (*FoundChunk) {&#10;      if (const FVoxelEntityData *EntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(GlobalCoord))) {&#10;        (*FoundChunk)-&gt;OnEntityDataModified(GlobalCoord, *EntityData);&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;TObjectPtr&lt;UEntityChunk&gt;&#10;UEntityManager::CreateEntityChunk(const FVoxelEntityData *EntityData) {&#10;  UEntityChunk *NewChunk = nullptr;&#10;&#10;  if (const UVoxelEntityDataAsset *EntityDataAsset =&#10;          EntityData-&gt;GetEntityDataAsset()) {&#10;    if (EntityDataAsset-&gt;EntityChunkClass) {&#10;      NewChunk =&#10;          NewObject&lt;UEntityChunk&gt;(this, EntityDataAsset-&gt;EntityChunkClass);&#10;    }&#10;  }&#10;&#10;  if (!NewChunk) {&#10;    NewChunk = NewObject&lt;UEntityChunk&gt;(this);&#10;  }&#10;&#10;  EntityChunks.Add(NewChunk);&#10;&#10;  return NewChunk;&#10;}&#10;&#10;void UEntityManager::UpdateEntityChunk(&#10;    const TObjectPtr&lt;UEntityChunk&gt; &amp;OriginalChunk) {&#10;  TArray&lt;FIntVector&gt; OriginalVoxels = OriginalChunk-&gt;GetManagedVoxels().Array();&#10;&#10;  for (const FIntVector &amp;VoxelCoord : OriginalVoxels) {&#10;    if (const FVoxelEntityData *EntityData =&#10;            dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;      OriginalChunk-&gt;RemoveEntity(VoxelCoord, *EntityData);&#10;    }&#10;    EntityToChunk.Remove(VoxelCoord);&#10;  }&#10;&#10;  EntityChunks.Remove(OriginalChunk);&#10;&#10;  TSet&lt;FIntVector&gt; VisitedVoxels;&#10;&#10;  for (const FIntVector &amp;VoxelCoord : OriginalVoxels) {&#10;    if (VisitedVoxels.Contains(VoxelCoord)) {&#10;      continue;&#10;    }&#10;&#10;    if (TSet&lt;FIntVector&gt; ChunkableVoxels;&#10;        GetChunkableEntityCoords(VoxelCoord, VisitedVoxels, ChunkableVoxels)) {&#10;      if (const FVoxelEntityData *EntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;        TObjectPtr&lt;UEntityChunk&gt; NewChunk = CreateEntityChunk(EntityData);&#10;&#10;        for (const FIntVector &amp;ChunkableVoxel : ChunkableVoxels) {&#10;          if (const FVoxelEntityData *VoxelEntityData =&#10;                  dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                      DataManager-&gt;GetVoxelData(ChunkableVoxel))) {&#10;            NewChunk-&gt;AddEntity(ChunkableVoxel, *VoxelEntityData);&#10;            EntityToChunk.Add(ChunkableVoxel, NewChunk);&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;bool UEntityManager::GetChunkableEntityCoords(&#10;    const FIntVector &amp;StartCoord, TSet&lt;FIntVector&gt; &amp;VisitedCoords,&#10;    TSet&lt;FIntVector&gt; &amp;ChunkableEntityCoords) const {&#10;  ChunkableEntityCoords.Reset();&#10;  TQueue&lt;FIntVector&gt; ToVisit;&#10;&#10;  const FVoxelEntityData *StartEntityData =&#10;      dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;          DataManager-&gt;GetVoxelData(StartCoord));&#10;&#10;  if (!StartEntityData) {&#10;    return false;&#10;  }&#10;&#10;  ToVisit.Enqueue(StartCoord);&#10;&#10;  while (!ToVisit.IsEmpty()) {&#10;    FIntVector CurrentCoord;&#10;    ToVisit.Dequeue(CurrentCoord);&#10;&#10;    if (VisitedCoords.Contains(CurrentCoord)) {&#10;      continue;&#10;    }&#10;&#10;    const FVoxelEntityData *CurrentEntityData =&#10;        dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;            DataManager-&gt;GetVoxelData(CurrentCoord));&#10;&#10;    if (!CurrentEntityData ||&#10;        !StartEntityData-&gt;IsChunkableWith(CurrentEntityData)) {&#10;      continue;&#10;    }&#10;&#10;    VisitedCoords.Add(CurrentCoord);&#10;    ChunkableEntityCoords.Add(CurrentCoord);&#10;&#10;    for (const FIntVector &amp;Offset : NeighborOffsets) {&#10;      if (const FIntVector NeighborCoord = CurrentCoord + Offset;&#10;          !VisitedCoords.Contains(NeighborCoord)) {&#10;        if (FVoxelEntityData::IsEntity(&#10;                DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;          ToVisit.Enqueue(NeighborCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  return !ChunkableEntityCoords.IsEmpty();&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;Managers/EntityManager.h&quot;&#10;&#10;#include &quot;Actors/VoxelWorldActor.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;EntityChunk.h&quot;&#10;#include &quot;EntityChunkComponent.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;&#10;void UEntityManager::Initialize() {&#10;  if (const TObjectPtr&lt;AVoxelWorldActor&gt; VoxelWorld =&#10;          Cast&lt;AVoxelWorldActor&gt;(GetOuter())) {&#10;    DataManager = VoxelWorld-&gt;GetDataManager();&#10;  }&#10;}&#10;&#10;void UEntityManager::Tick(const float DeltaTime) {&#10;  for (const TObjectPtr Chunk : EntityChunks) {&#10;    if (Chunk) {&#10;      Chunk-&gt;Tick(DeltaTime);&#10;    }&#10;  }&#10;}&#10;&#10;void UEntityManager::OnEntityDataCreated(const FIntVector &amp;GlobalCoord,&#10;                                         const FVoxelEntityData *EntityData) {&#10;  if (EntityToChunk.Contains(GlobalCoord) || !EntityData) {&#10;    return;&#10;  }&#10;&#10;  TSet&lt;TObjectPtr&lt;UEntityChunk&gt;&gt; ChunkableChunks;&#10;&#10;  for (const FIntVector &amp;NeighborOffset : NeighborOffsets) {&#10;    if (const TObjectPtr&lt;UEntityChunk&gt; *FoundChunk =&#10;            EntityToChunk.Find(GlobalCoord + NeighborOffset)) {&#10;      if (const FVoxelEntityData *NeighborEntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(GlobalCoord + NeighborOffset))) {&#10;        if (EntityData-&gt;IsChunkableWith(NeighborEntityData)) {&#10;          ChunkableChunks.Add(*FoundChunk);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  TObjectPtr&lt;UEntityChunk&gt; TargetChunk;&#10;&#10;  if (ChunkableChunks.IsEmpty()) {&#10;    TargetChunk = CreateEntityChunk(EntityData);&#10;  } else {&#10;    TargetChunk = ChunkableChunks.Array()[0];&#10;    ChunkableChunks.Remove(TargetChunk);&#10;&#10;    for (UEntityChunk *ChunkToMerge : ChunkableChunks) {&#10;      TArray&lt;FIntVector&gt; VoxelsToMove =&#10;          ChunkToMerge-&gt;GetManagedVoxels().Array();&#10;&#10;      for (const FIntVector &amp;VoxelCoord : VoxelsToMove) {&#10;        if (const FVoxelEntityData *VoxelEntityData =&#10;                dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                    DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;          ChunkToMerge-&gt;RemoveEntity(VoxelCoord, *VoxelEntityData);&#10;          TargetChunk-&gt;AddEntity(VoxelCoord, *VoxelEntityData);&#10;          EntityToChunk[VoxelCoord] = TargetChunk;&#10;        }&#10;      }&#10;&#10;      EntityChunks.Remove(ChunkToMerge);&#10;    }&#10;  }&#10;&#10;  TargetChunk-&gt;AddEntity(GlobalCoord, *EntityData);&#10;  EntityToChunk.Add(GlobalCoord, TargetChunk);&#10;}&#10;&#10;void UEntityManager::OnEntityDataDestroyed(const FIntVector &amp;GlobalCoord) {&#10;  if (!EntityToChunk.Contains(GlobalCoord)) {&#10;    return;&#10;  }&#10;&#10;  UEntityChunk *OwningChunk = EntityToChunk.FindAndRemoveChecked(GlobalCoord);&#10;&#10;  if (const FVoxelEntityData *EntityData =&#10;          dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;              DataManager-&gt;GetVoxelData(GlobalCoord))) {&#10;    OwningChunk-&gt;RemoveEntity(GlobalCoord, *EntityData);&#10;  }&#10;&#10;  if (OwningChunk-&gt;IsEmpty()) {&#10;    EntityChunks.Remove(OwningChunk);&#10;  } else {&#10;    UpdateEntityChunk(OwningChunk);&#10;  }&#10;}&#10;&#10;void UEntityManager::OnEntityDataModified(const FIntVector &amp;GlobalCoord) {&#10;  if (const TObjectPtr&lt;UEntityChunk&gt; *FoundChunk =&#10;          EntityToChunk.Find(GlobalCoord)) {&#10;    if (*FoundChunk) {&#10;      if (const FVoxelEntityData *EntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(GlobalCoord))) {&#10;        (*FoundChunk)-&gt;OnEntityDataModified(GlobalCoord, *EntityData);&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;TObjectPtr&lt;UEntityChunk&gt;&#10;UEntityManager::CreateEntityChunk(const FVoxelEntityData *EntityData) {&#10;  UEntityChunk *NewChunk = nullptr;&#10;&#10;  if (const UVoxelEntityDataAsset *EntityDataAsset =&#10;          EntityData-&gt;GetEntityDataAsset()) {&#10;    if (EntityDataAsset-&gt;EntityChunkClass) {&#10;      NewChunk =&#10;          NewObject&lt;UEntityChunk&gt;(this, EntityDataAsset-&gt;EntityChunkClass);&#10;    }&#10;&#10;    if (!NewChunk) {&#10;      NewChunk = NewObject&lt;UEntityChunk&gt;(this);&#10;    }&#10;&#10;    // Create and add components based on EntityDataAsset configuration&#10;    for (const TSubclassOf&lt;UEntityChunkComponent&gt; &amp;ComponentClass :&#10;         EntityDataAsset-&gt;ComponentClasses) {&#10;      if (ComponentClass) {&#10;        UEntityChunkComponent *NewComponent =&#10;            NewObject&lt;UEntityChunkComponent&gt;(NewChunk, ComponentClass);&#10;        NewChunk-&gt;AddComponent(NewComponent);&#10;      }&#10;    }&#10;  }&#10;&#10;  if (!NewChunk) {&#10;    NewChunk = NewObject&lt;UEntityChunk&gt;(this);&#10;  }&#10;&#10;  EntityChunks.Add(NewChunk);&#10;&#10;  return NewChunk;&#10;}&#10;&#10;void UEntityManager::UpdateEntityChunk(&#10;    const TObjectPtr&lt;UEntityChunk&gt; &amp;OriginalChunk) {&#10;  TArray&lt;FIntVector&gt; OriginalVoxels = OriginalChunk-&gt;GetManagedVoxels().Array();&#10;&#10;  for (const FIntVector &amp;VoxelCoord : OriginalVoxels) {&#10;    if (const FVoxelEntityData *EntityData =&#10;            dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;      OriginalChunk-&gt;RemoveEntity(VoxelCoord, *EntityData);&#10;    }&#10;    EntityToChunk.Remove(VoxelCoord);&#10;  }&#10;&#10;  EntityChunks.Remove(OriginalChunk);&#10;&#10;  TSet&lt;FIntVector&gt; VisitedVoxels;&#10;&#10;  for (const FIntVector &amp;VoxelCoord : OriginalVoxels) {&#10;    if (VisitedVoxels.Contains(VoxelCoord)) {&#10;      continue;&#10;    }&#10;&#10;    if (TSet&lt;FIntVector&gt; ChunkableVoxels;&#10;        GetChunkableEntityCoords(VoxelCoord, VisitedVoxels, ChunkableVoxels)) {&#10;      if (const FVoxelEntityData *EntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;        TObjectPtr&lt;UEntityChunk&gt; NewChunk = CreateEntityChunk(EntityData);&#10;&#10;        for (const FIntVector &amp;ChunkableVoxel : ChunkableVoxels) {&#10;          if (const FVoxelEntityData *VoxelEntityData =&#10;                  dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                      DataManager-&gt;GetVoxelData(ChunkableVoxel))) {&#10;            NewChunk-&gt;AddEntity(ChunkableVoxel, *VoxelEntityData);&#10;            EntityToChunk.Add(ChunkableVoxel, NewChunk);&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;bool UEntityManager::GetChunkableEntityCoords(&#10;    const FIntVector &amp;StartCoord, TSet&lt;FIntVector&gt; &amp;VisitedCoords,&#10;    TSet&lt;FIntVector&gt; &amp;ChunkableEntityCoords) const {&#10;  ChunkableEntityCoords.Reset();&#10;  TQueue&lt;FIntVector&gt; ToVisit;&#10;&#10;  const FVoxelEntityData *StartEntityData =&#10;      dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;          DataManager-&gt;GetVoxelData(StartCoord));&#10;&#10;  if (!StartEntityData) {&#10;    return false;&#10;  }&#10;&#10;  ToVisit.Enqueue(StartCoord);&#10;&#10;  while (!ToVisit.IsEmpty()) {&#10;    FIntVector CurrentCoord;&#10;    ToVisit.Dequeue(CurrentCoord);&#10;&#10;    if (VisitedCoords.Contains(CurrentCoord)) {&#10;      continue;&#10;    }&#10;&#10;    const FVoxelEntityData *CurrentEntityData =&#10;        dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;            DataManager-&gt;GetVoxelData(CurrentCoord));&#10;&#10;    if (!CurrentEntityData ||&#10;        !StartEntityData-&gt;IsChunkableWith(CurrentEntityData)) {&#10;      continue;&#10;    }&#10;&#10;    VisitedCoords.Add(CurrentCoord);&#10;    ChunkableEntityCoords.Add(CurrentCoord);&#10;&#10;    for (const FIntVector &amp;Offset : NeighborOffsets) {&#10;      if (const FIntVector NeighborCoord = CurrentCoord + Offset;&#10;          !VisitedCoords.Contains(NeighborCoord)) {&#10;        if (FVoxelEntityData::IsEntity(&#10;                DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;          ToVisit.Enqueue(NeighborCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  return !ChunkableEntityCoords.IsEmpty();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Components/HealthComponent.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Components/HealthComponent.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunkComponent.h&quot;&#10;#include &quot;HealthComponent.generated.h&quot;&#10;&#10;UCLASS()&#10;class VOXEL_API UHealthComponent : public UEntityChunkComponent {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void OnEntityAdded(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) override;&#10;  virtual void OnEntityRemoved(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) override;&#10;&#10;  float GetTotalHealth() const { return TotalHealth; }&#10;&#10;private:&#10;  UPROPERTY()&#10;  float TotalHealth = 0.0f;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Components/TargetComponent.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Components/TargetComponent.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityComponent.h&quot;&#10;#include &quot;TargetComponent.generated.h&quot;&#10;&#10;UCLASS()&#10;class VOXEL_API UTargetComponent : public UEntityComponent {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void Tick(float DeltaTime) override;&#10;  virtual float GetTargetPriority(TObjectPtr&lt;AActor&gt; TargetCandidate);&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TSubclassOf&lt;AActor&gt; TargetClass;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  uint8 TargetCount;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TArray&lt;TObjectPtr&lt;AActor&gt;&gt; Targets;&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunkComponent.h&quot;&#10;#include &quot;TargetComponent.generated.h&quot;&#10;&#10;UCLASS()&#10;class VOXEL_API UTargetComponent : public UEntityChunkComponent {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void Tick(float DeltaTime) override;&#10;  virtual float GetTargetPriority(TObjectPtr&lt;AActor&gt; TargetCandidate);&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TSubclassOf&lt;AActor&gt; TargetClass;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  uint8 TargetCount = 1;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TArray&lt;TObjectPtr&lt;AActor&gt;&gt; Targets;&#10;&#10;private:&#10;  void UpdateTargets();&#10;  bool IsValidTarget(AActor* Actor) const;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/DataAssets/VoxelEntityDataAsset.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/DataAssets/VoxelEntityDataAsset.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;DataAssets/VoxelBlockDataAsset.h&quot;&#10;#include &quot;VoxelEntityDataAsset.generated.h&quot;&#10;&#10;class UEntityChunk;&#10;&#10;UCLASS()&#10;class UVoxelEntityDataAsset : public UVoxelBlockDataAsset {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = &quot;Entity&quot;)&#10;  TSubclassOf&lt;UEntityChunk&gt; EntityChunkClass;&#10;};&#10;&#10;USTRUCT()&#10;struct FVoxelEntityData : public FVoxelBlockData {&#10;  GENERATED_BODY()&#10;&#10;  FVoxelEntityData() = default;&#10;&#10;  static bool IsEntity(const FVoxelBaseData *VoxelBaseData) {&#10;    return dynamic_cast&lt;const FVoxelEntityData *&gt;(VoxelBaseData) != nullptr;&#10;  }&#10;&#10;  explicit FVoxelEntityData(const TObjectPtr&lt;UVoxelEntityDataAsset&gt; &amp;InPtr,&#10;                            const float InDurability)&#10;      : FVoxelBlockData(InPtr, InDurability) {}&#10;&#10;  TObjectPtr&lt;UVoxelEntityDataAsset&gt; GetEntityDataAsset() const {&#10;    return Cast&lt;UVoxelEntityDataAsset&gt;(DataAsset);&#10;  }&#10;&#10;  virtual bool IsChunkableWith(const FVoxelEntityData *Other) const {&#10;    if (!Other || !DataAsset) {&#10;      return false;&#10;    }&#10;&#10;    return GetEntityDataAsset()-&gt;GetClass() ==&#10;           Other-&gt;GetEntityDataAsset()-&gt;GetClass();&#10;  }&#10;&#10;  virtual float GetDensity() const override {&#10;    return DataAsset ? DataAsset-&gt;BaseDensity * Durability /&#10;                           GetBlockDataAsset()-&gt;MaxDurability&#10;                     : -1.f;&#10;  }&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;DataAssets/VoxelBlockDataAsset.h&quot;&#10;#include &quot;VoxelEntityDataAsset.generated.h&quot;&#10;&#10;class UEntityChunk;&#10;class UEntityChunkComponent;&#10;&#10;UCLASS()&#10;class UVoxelEntityDataAsset : public UVoxelBlockDataAsset {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = &quot;Entity&quot;)&#10;  TSubclassOf&lt;UEntityChunk&gt; EntityChunkClass;&#10;&#10;  UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = &quot;Entity&quot;)&#10;  TArray&lt;TSubclassOf&lt;UEntityChunkComponent&gt;&gt; ComponentClasses;&#10;};&#10;&#10;USTRUCT()&#10;struct FVoxelEntityData : public FVoxelBlockData {&#10;  GENERATED_BODY()&#10;&#10;  FVoxelEntityData() = default;&#10;&#10;  static bool IsEntity(const FVoxelBaseData *VoxelBaseData) {&#10;    return dynamic_cast&lt;const FVoxelEntityData *&gt;(VoxelBaseData) != nullptr;&#10;  }&#10;&#10;  explicit FVoxelEntityData(const TObjectPtr&lt;UVoxelEntityDataAsset&gt; &amp;InPtr,&#10;                            const float InDurability)&#10;      : FVoxelBlockData(InPtr, InDurability) {}&#10;&#10;  TObjectPtr&lt;UVoxelEntityDataAsset&gt; GetEntityDataAsset() const {&#10;    return Cast&lt;UVoxelEntityDataAsset&gt;(DataAsset);&#10;  }&#10;&#10;  virtual bool IsChunkableWith(const FVoxelEntityData *Other) const {&#10;    if (!Other || !DataAsset) {&#10;      return false;&#10;    }&#10;&#10;    return GetEntityDataAsset()-&gt;GetClass() ==&#10;           Other-&gt;GetEntityDataAsset()-&gt;GetClass();&#10;  }&#10;&#10;  virtual float GetDensity() const override {&#10;    return DataAsset ? DataAsset-&gt;BaseDensity * Durability /&#10;                           GetBlockDataAsset()-&gt;MaxDurability&#10;                     : -1.f;&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Entity/Entity.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Entity/Entity.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Entity/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Entity/EntityChunk.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/EntityChunk.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunk.generated.h&quot;&#10;&#10;class UEntityManager;&#10;&#10;UCLASS(Abstract)&#10;class VOXEL_API UEntityChunk : public UObject {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void Tick(float DeltaTime);&#10;&#10;  virtual void AddEntity(const FIntVector &amp;VoxelCoord);&#10;  virtual void RemoveEntity(const FIntVector &amp;VoxelCoord);&#10;&#10;  bool IsEmpty() const;&#10;&#10;  virtual void OnEntityDataModified(const FIntVector &amp;VoxelCoord);&#10;&#10;  const TSet&lt;FIntVector&gt; &amp;GetManagedVoxels() const { return ManagedVoxels; }&#10;&#10;private:&#10;  UPROPERTY()&#10;  TSet&lt;FIntVector&gt; ManagedVoxels;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunk.generated.h&quot;&#10;&#10;class UEntityManager;&#10;class UEntityChunkComponent;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS(Abstract)&#10;class VOXEL_API UEntityChunk : public UObject {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void Tick(float DeltaTime);&#10;&#10;  virtual void AddEntity(const FIntVector &amp;VoxelCoord, const FVoxelEntityData&amp; EntityData);&#10;  virtual void RemoveEntity(const FIntVector &amp;VoxelCoord, const FVoxelEntityData&amp; EntityData);&#10;&#10;  bool IsEmpty() const;&#10;&#10;  virtual void OnEntityDataModified(const FIntVector &amp;VoxelCoord, const FVoxelEntityData&amp; EntityData);&#10;&#10;  const TSet&lt;FIntVector&gt; &amp;GetManagedVoxels() const { return ManagedVoxels; }&#10;&#10;  // Component management&#10;  template&lt;typename T&gt;&#10;  T* AddComponent();&#10;  &#10;  template&lt;typename T&gt;&#10;  T* GetComponent() const;&#10;  &#10;  void AddComponent(UEntityChunkComponent* Component);&#10;&#10;protected:&#10;  virtual void BeginPlay() {}&#10;&#10;private:&#10;  UPROPERTY()&#10;  TSet&lt;FIntVector&gt; ManagedVoxels;&#10;&#10;  UPROPERTY()&#10;  TArray&lt;TObjectPtr&lt;UEntityChunkComponent&gt;&gt; Components;&#10;};&#10;&#10;template&lt;typename T&gt;&#10;T* UEntityChunk::AddComponent() {&#10;  static_assert(TIsDerivedFrom&lt;T, UEntityChunkComponent&gt;::IsDerived, &quot;T must derive from UEntityChunkComponent&quot;);&#10;  &#10;  T* NewComponent = NewObject&lt;T&gt;(this);&#10;  AddComponent(NewComponent);&#10;  return NewComponent;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;T* UEntityChunk::GetComponent() const {&#10;  static_assert(TIsDerivedFrom&lt;T, UEntityChunkComponent&gt;::IsDerived, &quot;T must derive from UEntityChunkComponent&quot;);&#10;  &#10;  for (UEntityChunkComponent* Component : Components) {&#10;    if (T* CastedComponent = Cast&lt;T&gt;(Component)) {&#10;      return CastedComponent;&#10;    }&#10;  }&#10;  return nullptr;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/EntityChunkComponent.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/EntityChunkComponent.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunkComponent.generated.h&quot;&#10;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS(Abstract, BlueprintType)&#10;class VOXEL_API UEntityChunkComponent : public UObject {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void OnEntityAdded(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {}&#10;  virtual void OnEntityRemoved(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {}&#10;  virtual void OnEntityModified(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {}&#10;  virtual void Tick(float DeltaTime) {}&#10;&#10;protected:&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UEntityChunk&gt; OwnerChunk;&#10;&#10;  friend class UEntityChunk;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Logic/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Logic/EntityChunk.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunk.generated.h&quot;&#10;&#10;class UEntityManager;&#10;&#10;UCLASS()&#10;class VOXEL_API UEntityChunk : public UObject&#10;{&#10;&#9;GENERATED_BODY()&#10;&#10;public:&#10;&#9;void Initialize(UEntityManager* InManager);&#10;&#9;void Tick(float DeltaTime);&#10;&#10;&#9;void AddVoxel(const FIntVector&amp; VoxelCoord);&#10;&#9;void RemoveVoxel(const FIntVector&amp; VoxelCoord);&#10;&#9;void MergeWith(UEntityChunk* OtherChunk);&#10;&#10;&#9;const TSet&lt;FIntVector&gt;&amp; GetVoxels() const;&#10;&#9;bool IsEmpty() const;&#10;&#10;&#9;// 이 청크에 속한 모든 복셀의 맵을 업데이트합니다.&#10;&#9;void UpdateVoxelMap();&#10;&#10;private:&#10;&#9;UPROPERTY()&#10;&#9;TSet&lt;FIntVector&gt; ManagedVoxels;&#10;&#10;&#9;UPROPERTY()&#10;&#9;TObjectPtr&lt;UEntityManager&gt; EntityManager;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Managers/EntityManager.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Managers/EntityManager.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityManager.generated.h&quot;&#10;&#10;class UEntityChunk;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS()&#10;class VOXEL_API UEntityManager : public UObject {&#10;  GENERATED_BODY()&#10;&#10;  const FIntVector NeighborOffsets[6] = {&#10;      FIntVector(1, 0, 0),  FIntVector(-1, 0, 0), FIntVector(0, 1, 0),&#10;      FIntVector(0, -1, 0), FIntVector(0, 0, 1),  FIntVector(0, 0, -1)};&#10;&#10;public:&#10;  void Initialize();&#10;  void Tick(float DeltaTime);&#10;&#10;  void OnEntityDataCreated(const FIntVector &amp;GlobalCoord,&#10;                           const FVoxelEntityData *EntityData);&#10;  void OnEntityDataDestroyed(const FIntVector &amp;GlobalCoord);&#10;&#10;  void OnEntityDataModified(const FIntVector &amp;GlobalCoord);&#10;&#10;private:&#10;  void UpdateEntityChunk(const TObjectPtr&lt;UEntityChunk&gt; &amp;OriginalChunk);&#10;  bool GetChunkableEntityCoords(const FIntVector &amp;StartCoord,&#10;                                TSet&lt;FIntVector&gt; &amp;VisitedCoords,&#10;                                TSet&lt;FIntVector&gt; &amp;ChunkableEntityCoords) const;&#10;  TObjectPtr&lt;UEntityChunk&gt;&#10;  CreateEntityChunk(const FVoxelEntityData *EntityData);&#10;&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UDataManager&gt; DataManager;&#10;&#10;  UPROPERTY()&#10;  TMap&lt;FIntVector, TObjectPtr&lt;UEntityChunk&gt;&gt; EntityToChunk;&#10;&#10;  UPROPERTY()&#10;  TSet&lt;TObjectPtr&lt;UEntityChunk&gt;&gt; EntityChunks;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityManager.generated.h&quot;&#10;&#10;class UEntityChunk;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS()&#10;class VOXEL_API UEntityManager : public UObject {&#10;  GENERATED_BODY()&#10;&#10;  const FIntVector NeighborOffsets[6] = {&#10;      FIntVector(1, 0, 0),  FIntVector(-1, 0, 0), FIntVector(0, 1, 0),&#10;      FIntVector(0, -1, 0), FIntVector(0, 0, 1),  FIntVector(0, 0, -1)};&#10;&#10;public:&#10;  void Initialize();&#10;  void Tick(float DeltaTime);&#10;&#10;  void OnEntityDataCreated(const FIntVector &amp;GlobalCoord,&#10;                           const FVoxelEntityData *EntityData);&#10;  void OnEntityDataDestroyed(const FIntVector &amp;GlobalCoord,&#10;                             const FVoxelEntityData *EntityData);&#10;&#10;  void OnEntityDataModified(const FIntVector &amp;GlobalCoord,&#10;                           const FVoxelEntityData *EntityData);&#10;&#10;private:&#10;  void UpdateEntityChunk(const TObjectPtr&lt;UEntityChunk&gt; &amp;OriginalChunk);&#10;  bool GetChunkableEntityCoords(const FIntVector &amp;StartCoord,&#10;                                TSet&lt;FIntVector&gt; &amp;VisitedCoords,&#10;                                TSet&lt;FIntVector&gt; &amp;ChunkableEntityCoords) const;&#10;  TObjectPtr&lt;UEntityChunk&gt;&#10;  CreateEntityChunk(const FVoxelEntityData *EntityData);&#10;&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UDataManager&gt; DataManager;&#10;&#10;  UPROPERTY()&#10;  TMap&lt;FIntVector, TObjectPtr&lt;UEntityChunk&gt;&gt; EntityToChunk;&#10;&#10;  UPROPERTY()&#10;  TSet&lt;TObjectPtr&lt;UEntityChunk&gt;&gt; EntityChunks;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>