<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Entity/Entity.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Entity/Entity.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Entity/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Entity/EntityChunk.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/EntityChunk.cpp" />
              <option name="originalContent" value="#include &quot;EntityChunk.h&quot;&#10;&#10;void UEntityChunk::Tick(float DeltaTime) {}&#10;&#10;void UEntityChunk::AddEntity(const FIntVector &amp;VoxelCoord) {&#10;  ManagedVoxels.Add(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::RemoveEntity(const FIntVector &amp;VoxelCoord) {&#10;  ManagedVoxels.Remove(VoxelCoord);&#10;}&#10;&#10;bool UEntityChunk::IsEmpty() const { return ManagedVoxels.IsEmpty(); }&#10;&#10;void UEntityChunk::OnEntityDataModified(const FIntVector &amp;VoxelCoord) {}&#10;" />
              <option name="updatedContent" value="#include &quot;EntityChunk.h&quot;&#10;&#10;void UEntityChunk::Tick(float DeltaTime) {}&#10;&#10;void UEntityChunk::AddEntity(const FIntVector &amp;VoxelCoord) {&#10;  ManagedVoxels.Add(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::RemoveEntity(const FIntVector &amp;VoxelCoord) {&#10;  ManagedVoxels.Remove(VoxelCoord);&#10;}&#10;&#10;bool UEntityChunk::IsEmpty() const { return ManagedVoxels.IsEmpty(); }&#10;&#10;void UEntityChunk::OnEntityDataModified(const FIntVector &amp;VoxelCoord) {}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Logic/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Logic/EntityChunk.cpp" />
              <option name="updatedContent" value="#include &quot;Logic/EntityChunk.h&quot;&#10;#include &quot;Managers/EntityManager.h&quot;&#10;&#10;void UEntityChunk::Initialize(UEntityManager* InManager)&#10;{&#10;&#9;EntityManager = InManager;&#10;}&#10;&#10;void UEntityChunk::Tick(float DeltaTime)&#10;{&#10;&#9;// 이 청크에 대한 로직을 매 프레임 실행합니다. (예: 특정 액터 이동, 상태 변화 등)&#10;}&#10;&#10;void UEntityChunk::AddVoxel(const FIntVector&amp; VoxelCoord)&#10;{&#10;&#9;ManagedVoxels.Add(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::RemoveVoxel(const FIntVector&amp; VoxelCoord)&#10;{&#10;&#9;ManagedVoxels.Remove(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::MergeWith(UEntityChunk* OtherChunk)&#10;{&#10;&#9;if (!OtherChunk || OtherChunk == this) return;&#10;&#10;&#9;// 다른 청크의 복셀들을 현재 청크로 이동시킵니다.&#10;&#9;ManagedVoxels.Append(OtherChunk-&gt;GetVoxels());&#10;&#9;&#10;&#9;// 이동된 복셀들이 이제 현재 청크를 가리키도록 맵을 업데이트합니다.&#10;&#9;UpdateVoxelMap();&#10;}&#10;&#10;const TSet&lt;FIntVector&gt;&amp; UEntityChunk::GetVoxels() const&#10;{&#10;&#9;return ManagedVoxels;&#10;}&#10;&#10;bool UEntityChunk::IsEmpty() const&#10;{&#10;&#9;return ManagedVoxels.IsEmpty();&#10;}&#10;&#10;void UEntityChunk::UpdateVoxelMap()&#10;{&#10;&#9;if (EntityManager)&#10;&#9;{&#10;&#9;&#9;for (const FIntVector&amp; VoxelCoord : ManagedVoxels)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;EntityManager-&gt;UpdateVoxelChunkMapping(VoxelCoord, this);&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Managers/DataManager.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Managers/DataManager.cpp" />
              <option name="originalContent" value="#include &quot;Managers/DataManager.h&quot;&#10;&#10;#include &quot;Actors/VoxelChunkActor.h&quot;&#10;#include &quot;Actors/VoxelWorldActor.h&quot;&#10;#include &quot;DataAssets/VoxelBaseDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;Managers/DebugManager.h&quot;&#10;#include &quot;Managers/EntityManager.h&quot;&#10;#include &quot;Managers/MeshManager.h&quot;&#10;&#10;void UDataManager::Initialize(&#10;    const FIntVector &amp;InWorldSizeInChunks, const int32 InChunkSize,&#10;    const int32 InVoxelSize,&#10;    const TSubclassOf&lt;AVoxelChunkActor&gt; &amp;InVoxelChunkActor) {&#10;  const AVoxelWorldActor *VoxelWorld = Cast&lt;AVoxelWorldActor&gt;(GetOuter());&#10;  DebugManager = VoxelWorld-&gt;GetDebugManager();&#10;  MeshManager = VoxelWorld-&gt;GetMeshManager();&#10;  EntityManager = VoxelWorld-&gt;GetEntityManager();&#10;  WorldSizeInChunks = InWorldSizeInChunks;&#10;  ChunkSize = InChunkSize;&#10;  VoxelSize = InVoxelSize;&#10;  ChunkVolume = ChunkSize * ChunkSize * ChunkSize;&#10;  VoxelChunk = InVoxelChunkActor;&#10;&#10;  Chunks.Empty();&#10;}&#10;&#10;void UDataManager::LoadChunk(const FIntVector &amp;ChunkCoord) {&#10;  if (Chunks.Contains(ChunkCoord)) {&#10;    return;&#10;  }&#10;&#10;  if (!VoxelChunk) {&#10;    return;&#10;  }&#10;&#10;  FVoxelChunk NewChunk(ChunkSize);&#10;&#10;  UWorld *World = GetWorld();&#10;  if (!World) {&#10;    return;&#10;  }&#10;&#10;  FActorSpawnParameters SpawnParams;&#10;  SpawnParams.Owner = Cast&lt;AActor&gt;(GetOuter());&#10;&#10;  AVoxelChunkActor *NewVoxelChunk = World-&gt;SpawnActor&lt;AVoxelChunkActor&gt;(&#10;      VoxelChunk, GlobalToWorldCoord(ChunkToGlobalCoord(ChunkCoord)),&#10;      FRotator::ZeroRotator, SpawnParams);&#10;&#10;  if (NewVoxelChunk) {&#10;    if (AActor *Owner = Cast&lt;AActor&gt;(GetOuter())) {&#10;      NewVoxelChunk-&gt;AttachToActor(&#10;          Owner, FAttachmentTransformRules::KeepWorldTransform);&#10;    }&#10;    NewVoxelChunk-&gt;Initialize(ChunkCoord);&#10;    NewChunk.VoxelChunkActor = NewVoxelChunk;&#10;&#10;    Chunks.Add(ChunkCoord, MoveTemp(NewChunk));&#10;  }&#10;}&#10;&#10;void UDataManager::UnloadChunk(const FIntVector &amp;ChunkCoord) {&#10;  if (const FVoxelChunk *Chunk = Chunks.Find(ChunkCoord)) {&#10;    if (Chunk-&gt;VoxelChunkActor) {&#10;      Chunk-&gt;VoxelChunkActor-&gt;Destroy();&#10;    }&#10;    Chunks.Remove(ChunkCoord);&#10;  }&#10;}&#10;&#10;const FVoxelBaseData *&#10;UDataManager::GetVoxelData(const FIntVector &amp;GlobalCoord) const {&#10;  if (const FVoxelChunk *Chunk = Chunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    return Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord));&#10;  }&#10;  return new FVoxelVoidData();&#10;}&#10;&#10;void UDataManager::ModifyVoxelData(&#10;    const FIntVector &amp;GlobalCoord,&#10;    const TFunction&lt;void(FVoxelBaseData *)&gt; &amp;Modifier, const bool bAutoDebug) {&#10;  if (const FVoxelChunk *Chunk = Chunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    Modifier(Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord)));&#10;&#10;    if (DebugManager &amp;&amp; bAutoDebug) {&#10;      DebugManager-&gt;SetDebugVoxel(GlobalCoord);&#10;    }&#10;&#10;    if (MeshManager) {&#10;      MeshManager-&gt;SetDirtyChunk(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;void UDataManager::SetVoxelData(const FIntVector &amp;GlobalCoord,&#10;                                FVoxelBaseData *VoxelData,&#10;                                const bool bAutoDebug) {&#10;  if (const FVoxelChunk *Chunk = Chunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    const FVoxelBaseData *OldData =&#10;        Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord));&#10;&#10;    if (EntityManager &amp;&amp; FVoxelEntityData::IsEntity(OldData) &amp;&amp;&#10;        !FVoxelEntityData::IsEntity(VoxelData)) {&#10;      EntityManager-&gt;OnEntityVoxelDestroyed(GlobalCoord);&#10;    }&#10;&#10;    Chunk-&gt;SetVoxelData(GlobalCoordToIndex(GlobalCoord), VoxelData);&#10;&#10;    if (EntityManager &amp;&amp; !FVoxelEntityData::IsEntity(OldData) &amp;&amp;&#10;        FVoxelEntityData::IsEntity(VoxelData)) {&#10;      EntityManager-&gt;OnEntityVoxelCreated(GlobalCoord);&#10;    }&#10;&#10;    if (DebugManager &amp;&amp; bAutoDebug) {&#10;      DebugManager-&gt;SetDebugVoxel(GlobalCoord);&#10;    }&#10;&#10;    if (MeshManager) {&#10;      MeshManager-&gt;SetDirtyChunk(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;bool UDataManager::IsChunk(const FIntVector &amp;ChunkCoord) const {&#10;  return Chunks.Contains(ChunkCoord);&#10;}&#10;&#10;FVoxelChunk *UDataManager::GetChunk(const FIntVector &amp;ChunkCoord) {&#10;  return Chunks.Find(ChunkCoord);&#10;}&#10;&#10;FIntVector&#10;UDataManager::GlobalToChunkCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return FIntVector(&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.X) / ChunkSize),&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.Y) / ChunkSize),&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.Z) / ChunkSize));&#10;}&#10;&#10;FIntVector&#10;UDataManager::ChunkToGlobalCoord(const FIntVector &amp;ChunkCoord) const {&#10;  return ChunkCoord * ChunkSize;&#10;}&#10;&#10;FIntVector&#10;UDataManager::GlobalToLocalCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return GlobalCoord % ChunkSize;&#10;}&#10;&#10;int32 UDataManager::GlobalCoordToIndex(const FIntVector &amp;GlobalCoord) const {&#10;  return LocalCoordToIndex(GlobalToLocalCoord(GlobalCoord));&#10;}&#10;&#10;FIntVector&#10;UDataManager::LocalToGlobalCoord(const FIntVector &amp;LocalCoord,&#10;                                 const FIntVector &amp;ChunkCoord) const {&#10;  return ChunkToGlobalCoord(ChunkCoord) + LocalCoord;&#10;}&#10;&#10;FIntVector UDataManager::WorldToGlobalCoord(const FVector &amp;WorldCoord) const {&#10;  return FIntVector(FMath::RoundToInt(WorldCoord.X / VoxelSize),&#10;                    FMath::RoundToInt(WorldCoord.Y / VoxelSize),&#10;                    FMath::RoundToInt(WorldCoord.Z / VoxelSize));&#10;}&#10;&#10;FVector UDataManager::GlobalToWorldCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return FVector(GlobalCoord) * VoxelSize;&#10;}&#10;&#10;int32 UDataManager::LocalCoordToIndex(const FIntVector &amp;LocalCoord) const {&#10;  return LocalCoord.X + LocalCoord.Y * ChunkSize +&#10;         LocalCoord.Z * ChunkSize * ChunkSize;&#10;}" />
              <option name="updatedContent" value="#include &quot;Managers/DataManager.h&quot;&#10;&#10;#include &quot;Actors/VoxelChunkActor.h&quot;&#10;#include &quot;Actors/VoxelWorldActor.h&quot;&#10;#include &quot;DataAssets/VoxelBaseDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;Managers/DebugManager.h&quot;&#10;#include &quot;Managers/EntityManager.h&quot;&#10;#include &quot;Managers/MeshManager.h&quot;&#10;&#10;void UDataManager::Initialize(&#10;    const FIntVector &amp;InWorldSizeInChunks, const int32 InChunkSize,&#10;    const int32 InVoxelSize,&#10;    const TSubclassOf&lt;AVoxelChunkActor&gt; &amp;InVoxelChunkActor) {&#10;  const AVoxelWorldActor *VoxelWorld = Cast&lt;AVoxelWorldActor&gt;(GetOuter());&#10;  DebugManager = VoxelWorld-&gt;GetDebugManager();&#10;  MeshManager = VoxelWorld-&gt;GetMeshManager();&#10;  EntityManager = VoxelWorld-&gt;GetEntityManager();&#10;  WorldSizeInChunks = InWorldSizeInChunks;&#10;  ChunkSize = InChunkSize;&#10;  VoxelSize = InVoxelSize;&#10;  ChunkVolume = ChunkSize * ChunkSize * ChunkSize;&#10;  VoxelChunk = InVoxelChunkActor;&#10;&#10;  Chunks.Empty();&#10;}&#10;&#10;void UDataManager::LoadChunk(const FIntVector &amp;ChunkCoord) {&#10;  if (Chunks.Contains(ChunkCoord)) {&#10;    return;&#10;  }&#10;&#10;  if (!VoxelChunk) {&#10;    return;&#10;  }&#10;&#10;  FVoxelChunk NewChunk(ChunkSize);&#10;&#10;  UWorld *World = GetWorld();&#10;  if (!World) {&#10;    return;&#10;  }&#10;&#10;  FActorSpawnParameters SpawnParams;&#10;  SpawnParams.Owner = Cast&lt;AActor&gt;(GetOuter());&#10;&#10;  AVoxelChunkActor *NewVoxelChunk = World-&gt;SpawnActor&lt;AVoxelChunkActor&gt;(&#10;      VoxelChunk, GlobalToWorldCoord(ChunkToGlobalCoord(ChunkCoord)),&#10;      FRotator::ZeroRotator, SpawnParams);&#10;&#10;  if (NewVoxelChunk) {&#10;    if (AActor *Owner = Cast&lt;AActor&gt;(GetOuter())) {&#10;      NewVoxelChunk-&gt;AttachToActor(&#10;          Owner, FAttachmentTransformRules::KeepWorldTransform);&#10;    }&#10;    NewVoxelChunk-&gt;Initialize(ChunkCoord);&#10;    NewChunk.VoxelChunkActor = NewVoxelChunk;&#10;&#10;    Chunks.Add(ChunkCoord, MoveTemp(NewChunk));&#10;  }&#10;}&#10;&#10;void UDataManager::UnloadChunk(const FIntVector &amp;ChunkCoord) {&#10;  if (const FVoxelChunk *Chunk = Chunks.Find(ChunkCoord)) {&#10;    if (Chunk-&gt;VoxelChunkActor) {&#10;      Chunk-&gt;VoxelChunkActor-&gt;Destroy();&#10;    }&#10;    Chunks.Remove(ChunkCoord);&#10;  }&#10;}&#10;&#10;const FVoxelBaseData *&#10;UDataManager::GetVoxelData(const FIntVector &amp;GlobalCoord) const {&#10;  if (const FVoxelChunk *Chunk = Chunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    return Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord));&#10;  }&#10;  return new FVoxelVoidData();&#10;}&#10;&#10;void UDataManager::ModifyVoxelData(&#10;    const FIntVector &amp;GlobalCoord,&#10;    const TFunction&lt;void(FVoxelBaseData *)&gt; &amp;Modifier, const bool bAutoDebug) {&#10;  if (const FVoxelChunk *Chunk = Chunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    Modifier(Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord)));&#10;&#10;    if (DebugManager &amp;&amp; bAutoDebug) {&#10;      DebugManager-&gt;SetDebugVoxel(GlobalCoord);&#10;    }&#10;&#10;    if (MeshManager) {&#10;      MeshManager-&gt;SetDirtyChunk(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;void UDataManager::SetVoxelData(const FIntVector &amp;GlobalCoord,&#10;                                FVoxelBaseData *VoxelData,&#10;                                const bool bAutoDebug) {&#10;  if (const FVoxelChunk *Chunk = Chunks.Find(GlobalToChunkCoord(GlobalCoord))) {&#10;    const FVoxelBaseData *OldData =&#10;        Chunk-&gt;GetVoxelData(GlobalCoordToIndex(GlobalCoord));&#10;&#10;    if (EntityManager &amp;&amp; FVoxelEntityData::IsEntity(OldData) &amp;&amp;&#10;        !FVoxelEntityData::IsEntity(VoxelData)) {&#10;      EntityManager-&gt;OnEntityVoxelDestroyed(GlobalCoord);&#10;    }&#10;&#10;    Chunk-&gt;SetVoxelData(GlobalCoordToIndex(GlobalCoord), VoxelData);&#10;&#10;    if (EntityManager &amp;&amp; !FVoxelEntityData::IsEntity(OldData) &amp;&amp;&#10;        FVoxelEntityData::IsEntity(VoxelData)) {&#10;      const FVoxelEntityData* EntityData = static_cast&lt;const FVoxelEntityData*&gt;(VoxelData);&#10;      EntityManager-&gt;OnEntityVoxelCreated(GlobalCoord, EntityData);&#10;    }&#10;&#10;    if (DebugManager &amp;&amp; bAutoDebug) {&#10;      DebugManager-&gt;SetDebugVoxel(GlobalCoord);&#10;    }&#10;&#10;    if (MeshManager) {&#10;      MeshManager-&gt;SetDirtyChunk(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;bool UDataManager::IsChunk(const FIntVector &amp;ChunkCoord) const {&#10;  return Chunks.Contains(ChunkCoord);&#10;}&#10;&#10;FVoxelChunk *UDataManager::GetChunk(const FIntVector &amp;ChunkCoord) {&#10;  return Chunks.Find(ChunkCoord);&#10;}&#10;&#10;FIntVector&#10;UDataManager::GlobalToChunkCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return FIntVector(&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.X) / ChunkSize),&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.Y) / ChunkSize),&#10;      FMath::FloorToInt(static_cast&lt;float&gt;(GlobalCoord.Z) / ChunkSize));&#10;}&#10;&#10;FIntVector&#10;UDataManager::ChunkToGlobalCoord(const FIntVector &amp;ChunkCoord) const {&#10;  return ChunkCoord * ChunkSize;&#10;}&#10;&#10;FIntVector&#10;UDataManager::GlobalToLocalCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return GlobalCoord % ChunkSize;&#10;}&#10;&#10;int32 UDataManager::GlobalCoordToIndex(const FIntVector &amp;GlobalCoord) const {&#10;  return LocalCoordToIndex(GlobalToLocalCoord(GlobalCoord));&#10;}&#10;&#10;FIntVector&#10;UDataManager::LocalToGlobalCoord(const FIntVector &amp;LocalCoord,&#10;                                 const FIntVector &amp;ChunkCoord) const {&#10;  return ChunkToGlobalCoord(ChunkCoord) + LocalCoord;&#10;}&#10;&#10;FIntVector UDataManager::WorldToGlobalCoord(const FVector &amp;WorldCoord) const {&#10;  return FIntVector(FMath::RoundToInt(WorldCoord.X / VoxelSize),&#10;                    FMath::RoundToInt(WorldCoord.Y / VoxelSize),&#10;                    FMath::RoundToInt(WorldCoord.Z / VoxelSize));&#10;}&#10;&#10;FVector UDataManager::GlobalToWorldCoord(const FIntVector &amp;GlobalCoord) const {&#10;  return FVector(GlobalCoord) * VoxelSize;&#10;}&#10;&#10;int32 UDataManager::LocalCoordToIndex(const FIntVector &amp;LocalCoord) const {&#10;  return LocalCoord.X + LocalCoord.Y * ChunkSize +&#10;         LocalCoord.Z * ChunkSize * ChunkSize;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Managers/EntityManager.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Managers/EntityManager.cpp" />
              <option name="originalContent" value="#include &quot;Managers/EntityManager.h&quot;&#10;&#10;#include &quot;Actors/VoxelWorldActor.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;EntityChunk.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;&#10;void UEntityManager::Initialize() {&#10;  if (const TObjectPtr&lt;AVoxelWorldActor&gt; VoxelWorld =&#10;          Cast&lt;AVoxelWorldActor&gt;(GetOuter())) {&#10;    DataManager = VoxelWorld-&gt;GetDataManager();&#10;  }&#10;}&#10;&#10;void UEntityManager::Tick(const float DeltaTime) {&#10;  for (const TObjectPtr Chunk : EntityChunks) {&#10;    if (Chunk) {&#10;      Chunk-&gt;Tick(DeltaTime);&#10;    }&#10;  }&#10;}&#10;&#10;void UEntityManager::OnEntityDataCreated(const FIntVector &amp;GlobalCoord,&#10;                                         const FVoxelEntityData *EntityData) {&#10;  if (EntityToChunk.Contains(GlobalCoord) || !EntityData) {&#10;    return;&#10;  }&#10;&#10;  TSet&lt;TObjectPtr&lt;UEntityChunk&gt;&gt; ChunkableChunks;&#10;&#10;  for (const FIntVector &amp;NeighborOffset : NeighborOffsets) {&#10;    if (const TObjectPtr&lt;UEntityChunk&gt; *FoundChunk =&#10;            EntityToChunk.Find(GlobalCoord + NeighborOffset)) {&#10;      if (const FVoxelEntityData *NeighborEntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(GlobalCoord + NeighborOffset))) {&#10;        if (EntityData-&gt;IsChunkableWith(NeighborEntityData)) {&#10;          ChunkableChunks.Add(*FoundChunk);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  TObjectPtr&lt;UEntityChunk&gt; TargetChunk;&#10;&#10;  if (ChunkableChunks.IsEmpty()) {&#10;    TargetChunk = CreateEntityChunk(EntityData);&#10;  } else {&#10;    TargetChunk = ChunkableChunks.Array()[0];&#10;    ChunkableChunks.Remove(TargetChunk);&#10;&#10;    for (UEntityChunk *ChunkToMerge : ChunkableChunks) {&#10;      TArray&lt;FIntVector&gt; VoxelsToMove =&#10;          ChunkToMerge-&gt;GetManagedVoxels().Array();&#10;&#10;      for (const FIntVector &amp;VoxelCoord : VoxelsToMove) {&#10;        ChunkToMerge-&gt;RemoveEntity(VoxelCoord);&#10;        TargetChunk-&gt;AddEntity(VoxelCoord);&#10;        EntityToChunk[VoxelCoord] = TargetChunk;&#10;      }&#10;&#10;      EntityChunks.Remove(ChunkToMerge);&#10;    }&#10;  }&#10;&#10;  TargetChunk-&gt;AddEntity(GlobalCoord);&#10;  EntityToChunk.Add(GlobalCoord, TargetChunk);&#10;}&#10;&#10;void UEntityManager::OnEntityDataDestroyed(const FIntVector &amp;GlobalCoord) {&#10;  if (!EntityToChunk.Contains(GlobalCoord)) {&#10;    return;&#10;  }&#10;&#10;  UEntityChunk *OwningChunk = EntityToChunk.FindAndRemoveChecked(GlobalCoord);&#10;  OwningChunk-&gt;RemoveEntity(GlobalCoord);&#10;&#10;  if (OwningChunk-&gt;IsEmpty()) {&#10;    EntityChunks.Remove(OwningChunk);&#10;  } else {&#10;    UpdateEntityChunk(OwningChunk);&#10;  }&#10;}&#10;&#10;void UEntityManager::OnEntityDataModified(const FIntVector &amp;GlobalCoord) {&#10;  if (const TObjectPtr&lt;UEntityChunk&gt; *FoundChunk =&#10;          EntityToChunk.Find(GlobalCoord)) {&#10;    if (*FoundChunk) {&#10;      (*FoundChunk)-&gt;OnEntityDataModified(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;TObjectPtr&lt;UEntityChunk&gt;&#10;UEntityManager::CreateEntityChunk(const FVoxelEntityData *EntityData) {&#10;  UEntityChunk *NewChunk = nullptr;&#10;&#10;  if (const UVoxelEntityDataAsset *EntityDataAsset =&#10;          EntityData-&gt;GetEntityDataAsset()) {&#10;    if (EntityDataAsset-&gt;EntityChunkClass) {&#10;      NewChunk =&#10;          NewObject&lt;UEntityChunk&gt;(this, EntityDataAsset-&gt;EntityChunkClass);&#10;    }&#10;  }&#10;&#10;  if (!NewChunk) {&#10;    NewChunk = NewObject&lt;UEntityChunk&gt;(this);&#10;  }&#10;&#10;  EntityChunks.Add(NewChunk);&#10;&#10;  return NewChunk;&#10;}&#10;&#10;void UEntityManager::UpdateEntityChunk(&#10;    const TObjectPtr&lt;UEntityChunk&gt; &amp;OriginalChunk) {&#10;  TArray&lt;FIntVector&gt; OriginalVoxels = OriginalChunk-&gt;GetManagedVoxels().Array();&#10;&#10;  for (const FIntVector &amp;VoxelCoord : OriginalVoxels) {&#10;    OriginalChunk-&gt;RemoveEntity(VoxelCoord);&#10;    EntityToChunk.Remove(VoxelCoord);&#10;  }&#10;&#10;  EntityChunks.Remove(OriginalChunk);&#10;&#10;  TSet&lt;FIntVector&gt; VisitedVoxels;&#10;&#10;  for (const FIntVector &amp;VoxelCoord : OriginalVoxels) {&#10;    if (VisitedVoxels.Contains(VoxelCoord)) {&#10;      continue;&#10;    }&#10;&#10;    if (TSet&lt;FIntVector&gt; ChunkableVoxels;&#10;        GetChunkableEntityCoords(VoxelCoord, VisitedVoxels, ChunkableVoxels)) {&#10;      if (const FVoxelEntityData *EntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;        TObjectPtr&lt;UEntityChunk&gt; NewChunk = CreateEntityChunk(EntityData);&#10;&#10;        for (const FIntVector &amp;ChunkableVoxel : ChunkableVoxels) {&#10;          NewChunk-&gt;AddEntity(ChunkableVoxel);&#10;          EntityToChunk.Add(ChunkableVoxel, NewChunk);&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;bool UEntityManager::GetChunkableEntityCoords(&#10;    const FIntVector &amp;StartCoord, TSet&lt;FIntVector&gt; &amp;VisitedCoords,&#10;    TSet&lt;FIntVector&gt; &amp;ChunkableEntityCoords) const {&#10;  ChunkableEntityCoords.Reset();&#10;  TQueue&lt;FIntVector&gt; ToVisit;&#10;&#10;  const FVoxelEntityData *StartEntityData =&#10;      dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;          DataManager-&gt;GetVoxelData(StartCoord));&#10;&#10;  if (!StartEntityData) {&#10;    return false;&#10;  }&#10;&#10;  ToVisit.Enqueue(StartCoord);&#10;&#10;  while (!ToVisit.IsEmpty()) {&#10;    FIntVector CurrentCoord;&#10;    ToVisit.Dequeue(CurrentCoord);&#10;&#10;    if (VisitedCoords.Contains(CurrentCoord)) {&#10;      continue;&#10;    }&#10;&#10;    const FVoxelEntityData *CurrentEntityData =&#10;        dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;            DataManager-&gt;GetVoxelData(CurrentCoord));&#10;&#10;    if (!CurrentEntityData ||&#10;        !StartEntityData-&gt;IsChunkableWith(CurrentEntityData)) {&#10;      continue;&#10;    }&#10;&#10;    VisitedCoords.Add(CurrentCoord);&#10;    ChunkableEntityCoords.Add(CurrentCoord);&#10;&#10;    for (const FIntVector &amp;Offset : NeighborOffsets) {&#10;      if (const FIntVector NeighborCoord = CurrentCoord + Offset;&#10;          !VisitedCoords.Contains(NeighborCoord)) {&#10;        if (FVoxelEntityData::IsEntity(&#10;                DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;          ToVisit.Enqueue(NeighborCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  return !ChunkableEntityCoords.IsEmpty();&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;Managers/EntityManager.h&quot;&#10;&#10;#include &quot;Actors/VoxelWorldActor.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;EntityChunk.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;&#10;void UEntityManager::Initialize() {&#10;  if (const TObjectPtr&lt;AVoxelWorldActor&gt; VoxelWorld =&#10;          Cast&lt;AVoxelWorldActor&gt;(GetOuter())) {&#10;    DataManager = VoxelWorld-&gt;GetDataManager();&#10;  }&#10;}&#10;&#10;void UEntityManager::Tick(const float DeltaTime) {&#10;  for (const TObjectPtr Chunk : EntityChunks) {&#10;    if (Chunk) {&#10;      Chunk-&gt;Tick(DeltaTime);&#10;    }&#10;  }&#10;}&#10;&#10;void UEntityManager::OnEntityDataCreated(const FIntVector &amp;GlobalCoord,&#10;                                         const FVoxelEntityData *EntityData) {&#10;  if (EntityToChunk.Contains(GlobalCoord) || !EntityData) {&#10;    return;&#10;  }&#10;&#10;  TSet&lt;TObjectPtr&lt;UEntityChunk&gt;&gt; ChunkableChunks;&#10;&#10;  for (const FIntVector &amp;NeighborOffset : NeighborOffsets) {&#10;    if (const TObjectPtr&lt;UEntityChunk&gt; *FoundChunk =&#10;            EntityToChunk.Find(GlobalCoord + NeighborOffset)) {&#10;      if (const FVoxelEntityData *NeighborEntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(GlobalCoord + NeighborOffset))) {&#10;        if (EntityData-&gt;IsChunkableWith(NeighborEntityData)) {&#10;          ChunkableChunks.Add(*FoundChunk);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  TObjectPtr&lt;UEntityChunk&gt; TargetChunk;&#10;&#10;  if (ChunkableChunks.IsEmpty()) {&#10;    TargetChunk = CreateEntityChunk(EntityData);&#10;  } else {&#10;    TargetChunk = ChunkableChunks.Array()[0];&#10;    ChunkableChunks.Remove(TargetChunk);&#10;&#10;    for (UEntityChunk *ChunkToMerge : ChunkableChunks) {&#10;      TArray&lt;FIntVector&gt; VoxelsToMove =&#10;          ChunkToMerge-&gt;GetManagedVoxels().Array();&#10;&#10;      for (const FIntVector &amp;VoxelCoord : VoxelsToMove) {&#10;        ChunkToMerge-&gt;RemoveEntity(VoxelCoord);&#10;        TargetChunk-&gt;AddEntity(VoxelCoord);&#10;        EntityToChunk[VoxelCoord] = TargetChunk;&#10;      }&#10;&#10;      EntityChunks.Remove(ChunkToMerge);&#10;    }&#10;  }&#10;&#10;  TargetChunk-&gt;AddEntity(GlobalCoord);&#10;  EntityToChunk.Add(GlobalCoord, TargetChunk);&#10;}&#10;&#10;void UEntityManager::OnEntityDataDestroyed(const FIntVector &amp;GlobalCoord) {&#10;  if (!EntityToChunk.Contains(GlobalCoord)) {&#10;    return;&#10;  }&#10;&#10;  UEntityChunk *OwningChunk = EntityToChunk.FindAndRemoveChecked(GlobalCoord);&#10;  OwningChunk-&gt;RemoveEntity(GlobalCoord);&#10;&#10;  if (OwningChunk-&gt;IsEmpty()) {&#10;    EntityChunks.Remove(OwningChunk);&#10;  } else {&#10;    UpdateEntityChunk(OwningChunk);&#10;  }&#10;}&#10;&#10;void UEntityManager::OnEntityDataModified(const FIntVector &amp;GlobalCoord) {&#10;  if (const TObjectPtr&lt;UEntityChunk&gt; *FoundChunk =&#10;          EntityToChunk.Find(GlobalCoord)) {&#10;    if (*FoundChunk) {&#10;      (*FoundChunk)-&gt;OnEntityDataModified(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;TObjectPtr&lt;UEntityChunk&gt;&#10;UEntityManager::CreateEntityChunk(const FVoxelEntityData *EntityData) {&#10;  UEntityChunk *NewChunk = nullptr;&#10;&#10;  if (const UVoxelEntityDataAsset *EntityDataAsset =&#10;          EntityData-&gt;GetEntityDataAsset()) {&#10;    if (EntityDataAsset-&gt;EntityChunkClass) {&#10;      NewChunk =&#10;          NewObject&lt;UEntityChunk&gt;(this, EntityDataAsset-&gt;EntityChunkClass);&#10;    }&#10;  }&#10;&#10;  if (!NewChunk) {&#10;    NewChunk = NewObject&lt;UEntityChunk&gt;(this);&#10;  }&#10;&#10;  EntityChunks.Add(NewChunk);&#10;&#10;  return NewChunk;&#10;}&#10;&#10;void UEntityManager::UpdateEntityChunk(&#10;    const TObjectPtr&lt;UEntityChunk&gt; &amp;OriginalChunk) {&#10;  TArray&lt;FIntVector&gt; OriginalVoxels = OriginalChunk-&gt;GetManagedVoxels().Array();&#10;&#10;  for (const FIntVector &amp;VoxelCoord : OriginalVoxels) {&#10;    OriginalChunk-&gt;RemoveEntity(VoxelCoord);&#10;    EntityToChunk.Remove(VoxelCoord);&#10;  }&#10;&#10;  EntityChunks.Remove(OriginalChunk);&#10;&#10;  TSet&lt;FIntVector&gt; VisitedVoxels;&#10;&#10;  for (const FIntVector &amp;VoxelCoord : OriginalVoxels) {&#10;    if (VisitedVoxels.Contains(VoxelCoord)) {&#10;      continue;&#10;    }&#10;&#10;    if (TSet&lt;FIntVector&gt; ChunkableVoxels;&#10;        GetChunkableEntityCoords(VoxelCoord, VisitedVoxels, ChunkableVoxels)) {&#10;      if (const FVoxelEntityData *EntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;                  DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;        TObjectPtr&lt;UEntityChunk&gt; NewChunk = CreateEntityChunk(EntityData);&#10;&#10;        for (const FIntVector &amp;ChunkableVoxel : ChunkableVoxels) {&#10;          NewChunk-&gt;AddEntity(ChunkableVoxel);&#10;          EntityToChunk.Add(ChunkableVoxel, NewChunk);&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;bool UEntityManager::GetChunkableEntityCoords(&#10;    const FIntVector &amp;StartCoord, TSet&lt;FIntVector&gt; &amp;VisitedCoords,&#10;    TSet&lt;FIntVector&gt; &amp;ChunkableEntityCoords) const {&#10;  ChunkableEntityCoords.Reset();&#10;  TQueue&lt;FIntVector&gt; ToVisit;&#10;&#10;  const FVoxelEntityData *StartEntityData =&#10;      dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;          DataManager-&gt;GetVoxelData(StartCoord));&#10;&#10;  if (!StartEntityData) {&#10;    return false;&#10;  }&#10;&#10;  ToVisit.Enqueue(StartCoord);&#10;&#10;  while (!ToVisit.IsEmpty()) {&#10;    FIntVector CurrentCoord;&#10;    ToVisit.Dequeue(CurrentCoord);&#10;&#10;    if (VisitedCoords.Contains(CurrentCoord)) {&#10;      continue;&#10;    }&#10;&#10;    const FVoxelEntityData *CurrentEntityData =&#10;        dynamic_cast&lt;const FVoxelEntityData *&gt;(&#10;            DataManager-&gt;GetVoxelData(CurrentCoord));&#10;&#10;    if (!CurrentEntityData ||&#10;        !StartEntityData-&gt;IsChunkableWith(CurrentEntityData)) {&#10;      continue;&#10;    }&#10;&#10;    VisitedCoords.Add(CurrentCoord);&#10;    ChunkableEntityCoords.Add(CurrentCoord);&#10;&#10;    for (const FIntVector &amp;Offset : NeighborOffsets) {&#10;      if (const FIntVector NeighborCoord = CurrentCoord + Offset;&#10;          !VisitedCoords.Contains(NeighborCoord)) {&#10;        if (FVoxelEntityData::IsEntity(&#10;                DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;          ToVisit.Enqueue(NeighborCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  return !ChunkableEntityCoords.IsEmpty();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/DataAssets/VoxelEntityDataAsset.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/DataAssets/VoxelEntityDataAsset.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;DataAssets/VoxelBlockDataAsset.h&quot;&#10;#include &quot;VoxelEntityDataAsset.generated.h&quot;&#10;&#10;class UEntityChunk;&#10;&#10;UCLASS()&#10;class UVoxelEntityDataAsset : public UVoxelBlockDataAsset {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = &quot;Entity&quot;)&#10;  TSubclassOf&lt;UEntityChunk&gt; EntityChunkClass;&#10;};&#10;&#10;USTRUCT()&#10;struct FVoxelEntityData : public FVoxelBlockData {&#10;  GENERATED_BODY()&#10;&#10;  FVoxelEntityData() = default;&#10;&#10;  static bool IsEntity(const FVoxelBaseData *VoxelBaseData) {&#10;    return dynamic_cast&lt;const FVoxelEntityData *&gt;(VoxelBaseData) != nullptr;&#10;  }&#10;&#10;  explicit FVoxelEntityData(const TObjectPtr&lt;UVoxelEntityDataAsset&gt; &amp;InPtr,&#10;                            const float InDurability)&#10;      : FVoxelBlockData(InPtr, InDurability) {}&#10;&#10;  TObjectPtr&lt;UVoxelEntityDataAsset&gt; GetEntityDataAsset() const {&#10;    return Cast&lt;UVoxelEntityDataAsset&gt;(DataAsset);&#10;  }&#10;&#10;  virtual bool IsIdentical(const FVoxelEntityData *Other) const {&#10;    if (!Other || !DataAsset) {&#10;      return false;&#10;    }&#10;&#10;    return GetEntityDataAsset()-&gt;GetClass() ==&#10;           Other-&gt;GetEntityDataAsset()-&gt;GetClass();&#10;  }&#10;&#10;  virtual float GetDensity() const override {&#10;    return DataAsset ? DataAsset-&gt;BaseDensity * Durability /&#10;                           GetBlockDataAsset()-&gt;MaxDurability&#10;                     : -1.f;&#10;  }&#10;};" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;DataAssets/VoxelBlockDataAsset.h&quot;&#10;#include &quot;VoxelEntityDataAsset.generated.h&quot;&#10;&#10;class UEntityChunk;&#10;&#10;UCLASS()&#10;class UVoxelEntityDataAsset : public UVoxelBlockDataAsset {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = &quot;Entity&quot;)&#10;  TSubclassOf&lt;UEntityChunk&gt; EntityChunkClass;&#10;};&#10;&#10;USTRUCT()&#10;struct FVoxelEntityData : public FVoxelBlockData {&#10;  GENERATED_BODY()&#10;&#10;  FVoxelEntityData() = default;&#10;&#10;  static bool IsEntity(const FVoxelBaseData *VoxelBaseData) {&#10;    return dynamic_cast&lt;const FVoxelEntityData *&gt;(VoxelBaseData) != nullptr;&#10;  }&#10;&#10;  explicit FVoxelEntityData(const TObjectPtr&lt;UVoxelEntityDataAsset&gt; &amp;InPtr,&#10;                            const float InDurability)&#10;      : FVoxelBlockData(InPtr, InDurability) {}&#10;&#10;  TObjectPtr&lt;UVoxelEntityDataAsset&gt; GetEntityDataAsset() const {&#10;    return Cast&lt;UVoxelEntityDataAsset&gt;(DataAsset);&#10;  }&#10;&#10;  virtual bool IsIdentical(const FVoxelEntityData *Other) const {&#10;    if (!Other || !DataAsset) {&#10;      return false;&#10;    }&#10;&#10;    return GetEntityDataAsset()-&gt;GetClass() ==&#10;           Other-&gt;GetEntityDataAsset()-&gt;GetClass();&#10;  }&#10;&#10;  virtual float GetDensity() const override {&#10;    return DataAsset ? DataAsset-&gt;BaseDensity * Durability /&#10;                           GetBlockDataAsset()-&gt;MaxDurability&#10;                     : -1.f;&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Entity/Entity.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Entity/Entity.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Entity/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Entity/EntityChunk.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/EntityChunk.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunk.generated.h&quot;&#10;&#10;class UEntityManager;&#10;&#10;UCLASS(Abstract)&#10;class VOXEL_API UEntityChunk : public UObject {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void Tick(float DeltaTime);&#10;&#10;  void AddEntity(const FIntVector &amp;VoxelCoord);&#10;  void RemoveEntity(const FIntVector &amp;VoxelCoord);&#10;&#10;  bool IsEmpty() const;&#10;&#10;  virtual void OnEntityDataModified(const FIntVector &amp;VoxelCoord);&#10;&#10;  const TSet&lt;FIntVector&gt; &amp;GetManagedVoxels() const { return ManagedVoxels; }&#10;&#10;private:&#10;  UPROPERTY()&#10;  TSet&lt;FIntVector&gt; ManagedVoxels;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunk.generated.h&quot;&#10;&#10;class UEntityManager;&#10;&#10;UCLASS(Abstract)&#10;class VOXEL_API UEntityChunk : public UObject {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void Tick(float DeltaTime);&#10;&#10;  void AddEntity(const FIntVector &amp;VoxelCoord);&#10;  void RemoveEntity(const FIntVector &amp;VoxelCoord);&#10;&#10;  bool IsEmpty() const;&#10;&#10;  virtual void OnEntityDataModified(const FIntVector &amp;VoxelCoord);&#10;&#10;  const TSet&lt;FIntVector&gt; &amp;GetManagedVoxels() const { return ManagedVoxels; }&#10;&#10;private:&#10;  UPROPERTY()&#10;  TSet&lt;FIntVector&gt; ManagedVoxels;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/EntityChunks/NexusChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/EntityChunks/NexusChunk.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Logic/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Logic/EntityChunk.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunk.generated.h&quot;&#10;&#10;class UEntityManager;&#10;&#10;UCLASS()&#10;class VOXEL_API UEntityChunk : public UObject&#10;{&#10;&#9;GENERATED_BODY()&#10;&#10;public:&#10;&#9;void Initialize(UEntityManager* InManager);&#10;&#9;void Tick(float DeltaTime);&#10;&#10;&#9;void AddVoxel(const FIntVector&amp; VoxelCoord);&#10;&#9;void RemoveVoxel(const FIntVector&amp; VoxelCoord);&#10;&#9;void MergeWith(UEntityChunk* OtherChunk);&#10;&#10;&#9;const TSet&lt;FIntVector&gt;&amp; GetVoxels() const;&#10;&#9;bool IsEmpty() const;&#10;&#10;&#9;// 이 청크에 속한 모든 복셀의 맵을 업데이트합니다.&#10;&#9;void UpdateVoxelMap();&#10;&#10;private:&#10;&#9;UPROPERTY()&#10;&#9;TSet&lt;FIntVector&gt; ManagedVoxels;&#10;&#10;&#9;UPROPERTY()&#10;&#9;TObjectPtr&lt;UEntityManager&gt; EntityManager;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Managers/EntityManager.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Managers/EntityManager.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityManager.generated.h&quot;&#10;&#10;class UEntityChunk;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS()&#10;class VOXEL_API UEntityManager : public UObject {&#10;  GENERATED_BODY()&#10;&#10;  const FIntVector NeighborOffsets[6] = {&#10;      FIntVector(1, 0, 0),  FIntVector(-1, 0, 0), FIntVector(0, 1, 0),&#10;      FIntVector(0, -1, 0), FIntVector(0, 0, 1),  FIntVector(0, 0, -1)};&#10;&#10;public:&#10;  void Initialize();&#10;  void Tick(float DeltaTime);&#10;&#10;  void OnEntityDataCreated(const FIntVector &amp;GlobalCoord,&#10;                           const FVoxelEntityData *EntityData);&#10;  void OnEntityDataDestroyed(const FIntVector &amp;GlobalCoord);&#10;&#10;  void OnEntityDataModified(const FIntVector &amp;GlobalCoord);&#10;&#10;private:&#10;  void UpdateEntityChunk(const TObjectPtr&lt;UEntityChunk&gt; &amp;OriginalChunk);&#10;  bool GetChunkableEntityCoords(const FIntVector &amp;StartCoord,&#10;                                TSet&lt;FIntVector&gt; &amp;VisitedCoords,&#10;                                TSet&lt;FIntVector&gt; &amp;ChunkableEntityCoords) const;&#10;  TObjectPtr&lt;UEntityChunk&gt;&#10;  CreateEntityChunk(const FVoxelEntityData *EntityData);&#10;&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UDataManager&gt; DataManager;&#10;&#10;  UPROPERTY()&#10;  TMap&lt;FIntVector, TObjectPtr&lt;UEntityChunk&gt;&gt; EntityToChunk;&#10;&#10;  UPROPERTY()&#10;  TSet&lt;TObjectPtr&lt;UEntityChunk&gt;&gt; EntityChunks;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityManager.generated.h&quot;&#10;&#10;class UEntityChunk;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS()&#10;class VOXEL_API UEntityManager : public UObject {&#10;  GENERATED_BODY()&#10;&#10;  const FIntVector NeighborOffsets[6] = {&#10;      FIntVector(1, 0, 0),  FIntVector(-1, 0, 0), FIntVector(0, 1, 0),&#10;      FIntVector(0, -1, 0), FIntVector(0, 0, 1),  FIntVector(0, 0, -1)};&#10;&#10;public:&#10;  void Initialize();&#10;  void Tick(float DeltaTime);&#10;&#10;  void OnEntityDataCreated(const FIntVector &amp;GlobalCoord,&#10;                           const FVoxelEntityData *EntityData);&#10;  void OnEntityDataDestroyed(const FIntVector &amp;GlobalCoord);&#10;&#10;  void OnEntityDataModified(const FIntVector &amp;GlobalCoord);&#10;&#10;private:&#10;  void UpdateEntityChunk(const TObjectPtr&lt;UEntityChunk&gt; &amp;OriginalChunk);&#10;  bool GetChunkableEntityCoords(const FIntVector &amp;StartCoord,&#10;                                TSet&lt;FIntVector&gt; &amp;VisitedCoords,&#10;                                TSet&lt;FIntVector&gt; &amp;ChunkableEntityCoords) const;&#10;  TObjectPtr&lt;UEntityChunk&gt;&#10;  CreateEntityChunk(const FVoxelEntityData *EntityData);&#10;&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UDataManager&gt; DataManager;&#10;&#10;  UPROPERTY()&#10;  TMap&lt;FIntVector, TObjectPtr&lt;UEntityChunk&gt;&gt; EntityToChunk;&#10;&#10;  UPROPERTY()&#10;  TSet&lt;TObjectPtr&lt;UEntityChunk&gt;&gt; EntityChunks;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>