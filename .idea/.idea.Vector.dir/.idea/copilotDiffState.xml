<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Components/SurfaceComponent.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Components/SurfaceComponent.cpp" />
              <option name="originalContent" value="#include &quot;SurfaceComponent.h&quot;" />
              <option name="updatedContent" value="#include &quot;Components/SurfaceComponent.h&quot;&#10;#include &quot;Actors/EntityChunkActor.h&quot;&#10;&#10;const TArray&lt;FIntVector&gt; USurfaceComponent::NeighborOffsets = {&#10;    FIntVector(1, 0, 0),   // +X&#10;    FIntVector(-1, 0, 0),  // -X&#10;    FIntVector(0, 1, 0),   // +Y&#10;    FIntVector(0, -1, 0),  // -Y&#10;    FIntVector(0, 0, 1),   // +Z&#10;    FIntVector(0, 0, -1)   // -Z&#10;};&#10;&#10;USurfaceComponent::USurfaceComponent() {&#10;  PrimaryComponentTick.bCanEverTick = false;&#10;}&#10;&#10;FIntVector USurfaceComponent::GetClosestSurfaceVoxel(const FIntVector&amp; TargetCoord) const {&#10;  if (SurfaceVoxels.IsEmpty()) {&#10;    return FIntVector::ZeroValue;&#10;  }&#10;&#10;  FIntVector ClosestVoxel = *SurfaceVoxels.begin();&#10;  float MinDistanceSquared = FVector::DistSquared(&#10;      FVector(TargetCoord), FVector(ClosestVoxel));&#10;&#10;  for (const FIntVector&amp; SurfaceVoxel : SurfaceVoxels) {&#10;    const float DistanceSquared = FVector::DistSquared(&#10;        FVector(TargetCoord), FVector(SurfaceVoxel));&#10;    &#10;    if (DistanceSquared &lt; MinDistanceSquared) {&#10;      MinDistanceSquared = DistanceSquared;&#10;      ClosestVoxel = SurfaceVoxel;&#10;    }&#10;  }&#10;&#10;  return ClosestVoxel;&#10;}&#10;&#10;float USurfaceComponent::GetDistanceToClosestSurface(const FIntVector&amp; TargetCoord) const {&#10;  if (SurfaceVoxels.IsEmpty()) {&#10;    return -1.0f;&#10;  }&#10;&#10;  const FIntVector ClosestSurface = GetClosestSurfaceVoxel(TargetCoord);&#10;  return FVector::Dist(FVector(TargetCoord), FVector(ClosestSurface));&#10;}&#10;&#10;void USurfaceComponent::OnEntityAdded(const FIntVector&amp; GlobalCoord,&#10;                                     const FVoxelEntityData&amp; NewEntityData) {&#10;  // 새로 추가된 복셀과 그 주변의 표면 상태 업데이트&#10;  UpdateSurfaceAroundVoxel(GlobalCoord);&#10;}&#10;&#10;void USurfaceComponent::OnEntityRemoved(const FIntVector&amp; GlobalCoord) {&#10;  // 제거된 복셀은 더 이상 표면이 아님&#10;  SurfaceVoxels.Remove(GlobalCoord);&#10;  &#10;  // 주변 복셀들의 표면 상태 업데이트&#10;  UpdateSurfaceAroundVoxel(GlobalCoord);&#10;}&#10;&#10;void USurfaceComponent::OnEntityModified(const FIntVector&amp; GlobalCoord,&#10;                                        const FVoxelEntityData&amp; NewEntityData) {&#10;  // 수정된 복셀 주변의 표면 상태 업데이트&#10;  UpdateSurfaceAroundVoxel(GlobalCoord);&#10;}&#10;&#10;bool USurfaceComponent::IsSurfaceVoxel(const FIntVector&amp; GlobalCoord) const {&#10;  if (!EntityChunkActor) {&#10;    return false;&#10;  }&#10;&#10;  const TSet&lt;FIntVector&gt;&amp; EntityCoords = EntityChunkActor-&gt;GetEntityCoords();&#10;  &#10;  // 해당 좌표에 엔티티가 없으면 표면이 아님&#10;  if (!EntityCoords.Contains(GlobalCoord)) {&#10;    return false;&#10;  }&#10;&#10;  // 인접한 6방향 중 하나라도 엔티티가 없으면 표면 복셀&#10;  for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;    const FIntVector NeighborCoord = GlobalCoord + Offset;&#10;    if (!EntityCoords.Contains(NeighborCoord)) {&#10;      return true;&#10;    }&#10;  }&#10;&#10;  return false;&#10;}&#10;&#10;void USurfaceComponent::UpdateSurfaceVoxels() {&#10;  SurfaceVoxels.Empty();&#10;  &#10;  if (!EntityChunkActor) {&#10;    return;&#10;  }&#10;&#10;  const TSet&lt;FIntVector&gt;&amp; EntityCoords = EntityChunkActor-&gt;GetEntityCoords();&#10;  &#10;  for (const FIntVector&amp; GlobalCoord : EntityCoords) {&#10;    if (IsSurfaceVoxel(GlobalCoord)) {&#10;      SurfaceVoxels.Add(GlobalCoord);&#10;    }&#10;  }&#10;}&#10;&#10;void USurfaceComponent::UpdateSurfaceAroundVoxel(const FIntVector&amp; GlobalCoord) {&#10;  if (!EntityChunkActor) {&#10;    return;&#10;  }&#10;&#10;  // 해당 복셀의 표면 상태 업데이트&#10;  if (IsSurfaceVoxel(GlobalCoord)) {&#10;    SurfaceVoxels.Add(GlobalCoord);&#10;  } else {&#10;    SurfaceVoxels.Remove(GlobalCoord);&#10;  }&#10;&#10;  // 인접 복셀들의 표면 상태도 업데이트&#10;  for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;    const FIntVector NeighborCoord = GlobalCoord + Offset;&#10;    &#10;    if (IsSurfaceVoxel(NeighborCoord)) {&#10;      SurfaceVoxels.Add(NeighborCoord);&#10;    } else {&#10;      SurfaceVoxels.Remove(NeighborCoord);&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Entity/Entity.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Entity/Entity.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Entity/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Entity/EntityChunk.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/EntityChunkComponent.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/EntityChunkComponent.cpp" />
              <option name="updatedContent" value="#include &quot;EntityChunkComponent.h&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Logic/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Logic/EntityChunk.cpp" />
              <option name="updatedContent" value="#include &quot;Logic/EntityChunk.h&quot;&#10;#include &quot;Managers/EntityManager.h&quot;&#10;&#10;void UEntityChunk::Initialize(UEntityManager* InManager)&#10;{&#10;&#9;EntityManager = InManager;&#10;}&#10;&#10;void UEntityChunk::Tick(float DeltaTime)&#10;{&#10;&#9;// 이 청크에 대한 로직을 매 프레임 실행합니다. (예: 특정 액터 이동, 상태 변화 등)&#10;}&#10;&#10;void UEntityChunk::AddVoxel(const FIntVector&amp; VoxelCoord)&#10;{&#10;&#9;ManagedVoxels.Add(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::RemoveVoxel(const FIntVector&amp; VoxelCoord)&#10;{&#10;&#9;ManagedVoxels.Remove(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::MergeWith(UEntityChunk* OtherChunk)&#10;{&#10;&#9;if (!OtherChunk || OtherChunk == this) return;&#10;&#10;&#9;// 다른 청크의 복셀들을 현재 청크로 이동시킵니다.&#10;&#9;ManagedVoxels.Append(OtherChunk-&gt;GetVoxels());&#10;&#9;&#10;&#9;// 이동된 복셀들이 이제 현재 청크를 가리키도록 맵을 업데이트합니다.&#10;&#9;UpdateVoxelMap();&#10;}&#10;&#10;const TSet&lt;FIntVector&gt;&amp; UEntityChunk::GetVoxels() const&#10;{&#10;&#9;return ManagedVoxels;&#10;}&#10;&#10;bool UEntityChunk::IsEmpty() const&#10;{&#10;&#9;return ManagedVoxels.IsEmpty();&#10;}&#10;&#10;void UEntityChunk::UpdateVoxelMap()&#10;{&#10;&#9;if (EntityManager)&#10;&#9;{&#10;&#9;&#9;for (const FIntVector&amp; VoxelCoord : ManagedVoxels)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;EntityManager-&gt;UpdateVoxelChunkMapping(VoxelCoord, this);&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Managers/BuildManager.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Managers/BuildManager.cpp" />
              <option name="originalContent" value="#include &quot;Managers/BuildManager.h&quot;&#10;&#10;#include &quot;DataAssets/VoxelBlockDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelBorderDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelVoidDataAsset.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;#include &quot;Managers/MeshManager.h&quot;&#10;&#10;void UBuildManager::InitializeComponent() {&#10;  Super::InitializeComponent();&#10;&#10;  if (const AActor* Owner = GetOwner()) {&#10;    DataManager = Owner-&gt;GetComponentByClass&lt;UDataManager&gt;();&#10;    MeshManager = Owner-&gt;GetComponentByClass&lt;UMeshManager&gt;();&#10;  }&#10;}&#10;&#10;void UBuildManager::DamageBlocksInRadius(const FIntVector&amp; CenterGlobalCoord,&#10;                                         const float Radius,&#10;                                         const float DamageAmount) const {&#10;  auto DamageLogic = [&amp;](const FIntVector&amp; GlobalCoord) {&#10;    if (!DataManager) {&#10;      return;&#10;    }&#10;&#10;    const FVoxelBlockData* BlockData = dynamic_cast&lt;const FVoxelBlockData*&gt;(&#10;        DataManager-&gt;GetVoxelData(GlobalCoord));&#10;    if (!BlockData) {&#10;      return;&#10;    }&#10;&#10;    DataManager-&gt;ModifyVoxelData(&#10;        GlobalCoord, [DamageAmount](FVoxelBaseData* ModifierBaseData) {&#10;          dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData)-&gt;Durability -=&#10;              DamageAmount;&#10;        });&#10;&#10;    if (BlockData-&gt;Durability &lt;= 0) {&#10;      DataManager-&gt;SetVoxelData(GlobalCoord, new FVoxelVoidData());&#10;    }&#10;  };&#10;&#10;  ProcessVoxelsInRadius(CenterGlobalCoord, Radius, DamageLogic);&#10;}&#10;&#10;void UBuildManager::ConstructBlocksInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    const float ConstructionAmount,&#10;    const TObjectPtr&lt;const UVoxelBlockDataAsset&gt;&amp; NewVoxelBlockDataAsset,&#10;    const FVoxelBlockParams&amp; VoxelParams) const {&#10;  auto ConstructLogic = [&amp;](const FIntVector&amp; GlobalCoord) {&#10;    if (!DataManager) {&#10;      return;&#10;    }&#10;&#10;    const FVoxelBaseData* VoxelData = DataManager-&gt;GetVoxelData(GlobalCoord);&#10;&#10;    const FVoxelBlockData* BlockData =&#10;        dynamic_cast&lt;const FVoxelBlockData*&gt;(VoxelData);&#10;&#10;    if (BlockData) {&#10;      DataManager-&gt;ModifyVoxelData(&#10;          GlobalCoord, [ConstructionAmount](FVoxelBaseData* ModifierBaseData) {&#10;            dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData)-&gt;Durability +=&#10;                ConstructionAmount;&#10;          });&#10;    }&#10;&#10;    if ((BlockData &amp;&amp; BlockData-&gt;Durability &gt;&#10;                          BlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability) ||&#10;        FVoxelBorderData::IsBorder(VoxelData)) {&#10;&#10;      if (BlockData) {&#10;        DataManager-&gt;ModifyVoxelData(&#10;            GlobalCoord, [&amp;](FVoxelBaseData* ModifierBaseData) {&#10;              FVoxelBlockData* ModifierBlockData =&#10;                  dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData);&#10;              ModifierBlockData-&gt;Durability =&#10;                  ModifierBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;            });&#10;      }&#10;&#10;      for (const FIntVector&amp; NeighborOffset : NeighborOffsets) {&#10;        if (const FIntVector NeighborGlobalCoord = GlobalCoord + NeighborOffset;&#10;            FVoxelVoidData::IsVoid(&#10;                DataManager-&gt;GetVoxelData(NeighborGlobalCoord))) {&#10;&#10;          const TUniquePtr&lt;FVoxelBlockParams&gt; NewVoxelParams(&#10;              static_cast&lt;FVoxelBlockParams*&gt;(VoxelParams.Clone()));&#10;          NewVoxelParams-&gt;Durability = ConstructionAmount;&#10;&#10;          if (FVoxelBaseData* NewVoxelData =&#10;                  NewVoxelBlockDataAsset-&gt;ConstructVoxelData(*NewVoxelParams)) {&#10;            DataManager-&gt;SetVoxelData(NeighborGlobalCoord, NewVoxelData);&#10;          }&#10;&#10;          for (const FIntVector&amp; CheckOffset : NeighborOffsets) {&#10;            const FIntVector CheckGlobalCoord =&#10;                NeighborGlobalCoord + CheckOffset;&#10;            if (CheckGlobalCoord == GlobalCoord) {&#10;              continue;&#10;            }&#10;&#10;            if (!IsSurfaceVoxel(CheckGlobalCoord)) {&#10;              DataManager-&gt;ModifyVoxelData(&#10;                  CheckGlobalCoord, [&amp;](FVoxelBaseData* CheckVoxelData) {&#10;                    if (FVoxelBlockData* CheckBlockData =&#10;                            dynamic_cast&lt;FVoxelBlockData*&gt;(CheckVoxelData)) {&#10;                      CheckBlockData-&gt;Durability =&#10;                          CheckBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;                    }&#10;                  });&#10;            }&#10;          }&#10;&#10;          if (!IsSurfaceVoxel(NeighborGlobalCoord)) {&#10;            DataManager-&gt;ModifyVoxelData(&#10;                NeighborGlobalCoord, [&amp;](FVoxelBaseData* NeighborVoxelData) {&#10;                  if (FVoxelBlockData* NeighborBlockData =&#10;                          dynamic_cast&lt;FVoxelBlockData*&gt;(NeighborVoxelData)) {&#10;                    NeighborBlockData-&gt;Durability =&#10;                        NeighborBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;                  }&#10;                });&#10;          }&#10;        }&#10;      }&#10;    }&#10;  };&#10;&#10;  ProcessVoxelsInRadius(CenterGlobalCoord, Radius, ConstructLogic);&#10;}&#10;&#10;void UBuildManager::GetGlobalCoordsInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    TSet&lt;FIntVector&gt;&amp; FoundGlobalCoords) const {&#10;  if (!DataManager) {&#10;    return;&#10;  }&#10;&#10;  const int32 RadiusInVoxels =&#10;      FMath::CeilToInt(Radius / DataManager-&gt;GetVoxelSize());&#10;  const int32 RadiusSquared = FMath::Square(RadiusInVoxels);&#10;&#10;  for (int32 z = -RadiusInVoxels; z &lt;= RadiusInVoxels; ++z) {&#10;    for (int32 y = -RadiusInVoxels; y &lt;= RadiusInVoxels; ++y) {&#10;      for (int32 x = -RadiusInVoxels; x &lt;= RadiusInVoxels; ++x) {&#10;        if (const int32 DistanceSquared = x * x + y * y + z * z;&#10;            DistanceSquared &lt;= RadiusSquared) {&#10;          const FIntVector GlobalCoord =&#10;              CenterGlobalCoord + FIntVector(x, y, z);&#10;          FoundGlobalCoords.Add(GlobalCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;UBuildManager::UBuildManager() {&#10;  bWantsInitializeComponent = true;&#10;}&#10;&#10;void UBuildManager::ProcessVoxelsInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    const TFunction&lt;void(const FIntVector&amp;)&gt;&amp; VoxelModifier) const {&#10;  if (!MeshManager || !DataManager) {&#10;    return;&#10;  }&#10;&#10;  TSet&lt;FIntVector&gt; GlobalCoordsInRadius;&#10;  GetGlobalCoordsInRadius(CenterGlobalCoord, Radius, GlobalCoordsInRadius);&#10;&#10;  TSet&lt;FIntVector&gt; GlobalCoordsToProcess;&#10;  TQueue&lt;FIntVector&gt; Queue;&#10;  TSet&lt;FIntVector&gt; Visited;&#10;&#10;  Queue.Enqueue(CenterGlobalCoord);&#10;  Visited.Add(CenterGlobalCoord);&#10;&#10;  while (!Queue.IsEmpty()) {&#10;    FIntVector CurrentGlobalCoord;&#10;    Queue.Dequeue(CurrentGlobalCoord);&#10;&#10;    if (IsSurfaceVoxel(CurrentGlobalCoord)) {&#10;      GlobalCoordsToProcess.Add(CurrentGlobalCoord);&#10;    }&#10;&#10;    for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;      const FIntVector NeighborCoord = CurrentGlobalCoord + Offset;&#10;&#10;      if (Visited.Contains(NeighborCoord) ||&#10;          !GlobalCoordsInRadius.Contains(NeighborCoord)) {&#10;        continue;&#10;      }&#10;&#10;      if (!FVoxelVoidData::IsVoid(DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;        Queue.Enqueue(NeighborCoord);&#10;        Visited.Add(NeighborCoord);&#10;      } else {&#10;        Visited.Add(NeighborCoord);&#10;      }&#10;    }&#10;  }&#10;&#10;  for (const FIntVector&amp; VoxelCoord : GlobalCoordsToProcess) {&#10;    VoxelModifier(VoxelCoord);&#10;  }&#10;&#10;  MeshManager-&gt;FlushDirtyChunks();&#10;}&#10;&#10;bool UBuildManager::IsSurfaceVoxel(const FIntVector&amp; VoxelCoord) const {&#10;  if (!DataManager) {&#10;    return false;&#10;  }&#10;&#10;  for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;    if (FVoxelVoidData::IsVoid(&#10;            DataManager-&gt;GetVoxelData(VoxelCoord + Offset))) {&#10;      return true;&#10;    }&#10;  }&#10;  return false;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;Managers/BuildManager.h&quot;&#10;&#10;#include &quot;DataAssets/VoxelBlockDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelBorderDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelVoidDataAsset.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;#include &quot;Managers/MeshManager.h&quot;&#10;&#10;void UBuildManager::InitializeComponent() {&#10;  Super::InitializeComponent();&#10;&#10;  if (const AActor* Owner = GetOwner()) {&#10;    DataManager = Owner-&gt;GetComponentByClass&lt;UDataManager&gt;();&#10;    MeshManager = Owner-&gt;GetComponentByClass&lt;UMeshManager&gt;();&#10;  }&#10;}&#10;&#10;void UBuildManager::DamageBlocksInRadius(const FIntVector&amp; CenterGlobalCoord,&#10;                                         const float Radius,&#10;                                         const float DamageAmount) const {&#10;  auto DamageLogic = [&amp;](const FIntVector&amp; GlobalCoord) {&#10;    if (!DataManager) {&#10;      return;&#10;    }&#10;&#10;    const FVoxelBlockData* BlockData = dynamic_cast&lt;const FVoxelBlockData*&gt;(&#10;        DataManager-&gt;GetVoxelData(GlobalCoord));&#10;    if (!BlockData) {&#10;      return;&#10;    }&#10;&#10;    DataManager-&gt;ModifyVoxelData(&#10;        GlobalCoord, [DamageAmount](FVoxelBaseData* ModifierBaseData) {&#10;          dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData)-&gt;Durability -=&#10;              DamageAmount;&#10;        });&#10;&#10;    if (BlockData-&gt;Durability &lt;= 0) {&#10;      DataManager-&gt;SetVoxelData(GlobalCoord, new FVoxelVoidData());&#10;    }&#10;  };&#10;&#10;  ProcessVoxelsInRadius(CenterGlobalCoord, Radius, DamageLogic);&#10;}&#10;&#10;void UBuildManager::ConstructBlocksInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    const float ConstructionAmount,&#10;    const TObjectPtr&lt;const UVoxelBlockDataAsset&gt;&amp; NewVoxelBlockDataAsset,&#10;    const FVoxelBlockParams&amp; VoxelParams) const {&#10;  auto ConstructLogic = [&amp;](const FIntVector&amp; GlobalCoord) {&#10;    if (!DataManager) {&#10;      return;&#10;    }&#10;&#10;    const FVoxelBaseData* VoxelData = DataManager-&gt;GetVoxelData(GlobalCoord);&#10;&#10;    const FVoxelBlockData* BlockData =&#10;        dynamic_cast&lt;const FVoxelBlockData*&gt;(VoxelData);&#10;&#10;    if (BlockData) {&#10;      DataManager-&gt;ModifyVoxelData(&#10;          GlobalCoord, [ConstructionAmount](FVoxelBaseData* ModifierBaseData) {&#10;            dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData)-&gt;Durability +=&#10;                ConstructionAmount;&#10;          });&#10;    }&#10;&#10;    if ((BlockData &amp;&amp; BlockData-&gt;Durability &gt;&#10;                          BlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability) ||&#10;        FVoxelBorderData::IsBorder(VoxelData)) {&#10;&#10;      if (BlockData) {&#10;        DataManager-&gt;ModifyVoxelData(&#10;            GlobalCoord, [&amp;](FVoxelBaseData* ModifierBaseData) {&#10;              FVoxelBlockData* ModifierBlockData =&#10;                  dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData);&#10;              ModifierBlockData-&gt;Durability =&#10;                  ModifierBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;            });&#10;      }&#10;&#10;      for (const FIntVector&amp; NeighborOffset : NeighborOffsets) {&#10;        if (const FIntVector NeighborGlobalCoord = GlobalCoord + NeighborOffset;&#10;            FVoxelVoidData::IsVoid(&#10;                DataManager-&gt;GetVoxelData(NeighborGlobalCoord))) {&#10;&#10;          const TUniquePtr&lt;FVoxelBlockParams&gt; NewVoxelParams(&#10;              static_cast&lt;FVoxelBlockParams*&gt;(VoxelParams.Clone()));&#10;          NewVoxelParams-&gt;Durability = ConstructionAmount;&#10;&#10;          if (FVoxelBaseData* NewVoxelData =&#10;                  NewVoxelBlockDataAsset-&gt;ConstructVoxelData(*NewVoxelParams)) {&#10;            DataManager-&gt;SetVoxelData(NeighborGlobalCoord, NewVoxelData);&#10;          }&#10;&#10;          for (const FIntVector&amp; CheckOffset : NeighborOffsets) {&#10;            const FIntVector CheckGlobalCoord =&#10;                NeighborGlobalCoord + CheckOffset;&#10;            if (CheckGlobalCoord == GlobalCoord) {&#10;              continue;&#10;            }&#10;&#10;            if (!IsSurfaceVoxel(CheckGlobalCoord)) {&#10;              DataManager-&gt;ModifyVoxelData(&#10;                  CheckGlobalCoord, [&amp;](FVoxelBaseData* CheckVoxelData) {&#10;                    if (FVoxelBlockData* CheckBlockData =&#10;                            dynamic_cast&lt;FVoxelBlockData*&gt;(CheckVoxelData)) {&#10;                      CheckBlockData-&gt;Durability =&#10;                          CheckBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;                    }&#10;                  });&#10;            }&#10;          }&#10;&#10;          if (!IsSurfaceVoxel(NeighborGlobalCoord)) {&#10;            DataManager-&gt;ModifyVoxelData(&#10;                NeighborGlobalCoord, [&amp;](FVoxelBaseData* NeighborVoxelData) {&#10;                  if (FVoxelBlockData* NeighborBlockData =&#10;                          dynamic_cast&lt;FVoxelBlockData*&gt;(NeighborVoxelData)) {&#10;                    NeighborBlockData-&gt;Durability =&#10;                        NeighborBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;                  }&#10;                });&#10;          }&#10;        }&#10;      }&#10;    }&#10;  };&#10;&#10;  ProcessVoxelsInRadius(CenterGlobalCoord, Radius, ConstructLogic);&#10;}&#10;&#10;void UBuildManager::GetGlobalCoordsInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    TSet&lt;FIntVector&gt;&amp; FoundGlobalCoords) const {&#10;  if (!DataManager) {&#10;    return;&#10;  }&#10;&#10;  const int32 RadiusInVoxels =&#10;      FMath::CeilToInt(Radius / DataManager-&gt;GetVoxelSize());&#10;  const int32 RadiusSquared = FMath::Square(RadiusInVoxels);&#10;&#10;  for (int32 z = -RadiusInVoxels; z &lt;= RadiusInVoxels; ++z) {&#10;    for (int32 y = -RadiusInVoxels; y &lt;= RadiusInVoxels; ++y) {&#10;      for (int32 x = -RadiusInVoxels; x &lt;= RadiusInVoxels; ++x) {&#10;        if (const int32 DistanceSquared = x * x + y * y + z * z;&#10;            DistanceSquared &lt;= RadiusSquared) {&#10;          const FIntVector GlobalCoord =&#10;              CenterGlobalCoord + FIntVector(x, y, z);&#10;          FoundGlobalCoords.Add(GlobalCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;UBuildManager::UBuildManager() {&#10;  bWantsInitializeComponent = true;&#10;}&#10;&#10;void UBuildManager::ProcessVoxelsInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    const TFunction&lt;void(const FIntVector&amp;)&gt;&amp; VoxelModifier) const {&#10;  if (!MeshManager || !DataManager) {&#10;    return;&#10;  }&#10;&#10;  TSet&lt;FIntVector&gt; GlobalCoordsInRadius;&#10;  GetGlobalCoordsInRadius(CenterGlobalCoord, Radius, GlobalCoordsInRadius);&#10;&#10;  TSet&lt;FIntVector&gt; GlobalCoordsToProcess;&#10;  TQueue&lt;FIntVector&gt; Queue;&#10;  TSet&lt;FIntVector&gt; Visited;&#10;&#10;  Queue.Enqueue(CenterGlobalCoord);&#10;  Visited.Add(CenterGlobalCoord);&#10;&#10;  while (!Queue.IsEmpty()) {&#10;    FIntVector CurrentGlobalCoord;&#10;    Queue.Dequeue(CurrentGlobalCoord);&#10;&#10;    if (IsSurfaceVoxel(CurrentGlobalCoord)) {&#10;      GlobalCoordsToProcess.Add(CurrentGlobalCoord);&#10;    }&#10;&#10;    for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;      const FIntVector NeighborCoord = CurrentGlobalCoord + Offset;&#10;&#10;      if (Visited.Contains(NeighborCoord) ||&#10;          !GlobalCoordsInRadius.Contains(NeighborCoord)) {&#10;        continue;&#10;      }&#10;&#10;      if (!FVoxelVoidData::IsVoid(DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;        Queue.Enqueue(NeighborCoord);&#10;        Visited.Add(NeighborCoord);&#10;      } else {&#10;        Visited.Add(NeighborCoord);&#10;      }&#10;    }&#10;  }&#10;&#10;  for (const FIntVector&amp; VoxelCoord : GlobalCoordsToProcess) {&#10;    VoxelModifier(VoxelCoord);&#10;  }&#10;&#10;  MeshManager-&gt;FlushDirtyChunks();&#10;&#10;  // 엔티티 병합/분할 처리&#10;  if (DataManager &amp;&amp; DataManager-&gt;EntityManager) {&#10;    DataManager-&gt;EntityManager-&gt;FlushDirtyEntities();&#10;  }&#10;}&#10;&#10;bool UBuildManager::IsSurfaceVoxel(const FIntVector&amp; VoxelCoord) const {&#10;  if (!DataManager) {&#10;    return false;&#10;  }&#10;&#10;  for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;    if (FVoxelVoidData::IsVoid(&#10;            DataManager-&gt;GetVoxelData(VoxelCoord + Offset))) {&#10;      return true;&#10;    }&#10;  }&#10;  return false;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Managers/EntityManager.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Managers/EntityManager.cpp" />
              <option name="originalContent" value="#include &quot;Managers/EntityManager.h&quot;&#10;&#10;#include &quot;Actors/EntityChunkActor.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;&#10;void UEntityManager::InitializeComponent() {&#10;  Super::InitializeComponent();&#10;&#10;  if (const AActor* Owner = GetOwner()) {&#10;    DataManager = Owner-&gt;GetComponentByClass&lt;UDataManager&gt;();&#10;  }&#10;}&#10;&#10;void UEntityManager::SetDirtyEntity(const FIntVector&amp; GlobalCoord) {&#10;  DirtyEntityVoxels.Add(GlobalCoord);&#10;}&#10;&#10;void UEntityManager::OnEntityModified(const FIntVector&amp; GlobalCoord,&#10;                                      const FVoxelEntityData&amp; EntityData) {&#10;  if (const TObjectPtr&lt;AEntityChunkActor&gt;* FoundChunk =&#10;          EntityToChunk.Find(GlobalCoord)) {&#10;    (*FoundChunk)-&gt;OnEntityModified(GlobalCoord, EntityData);&#10;  }&#10;}&#10;&#10;void UEntityManager::FlushDirtyEntities() {&#10;  TSet&lt;FIntVector&gt; ProcessedVoxels;&#10;&#10;  for (const FIntVector&amp; GlobalCoord : DirtyEntityVoxels) {&#10;    if (ProcessedVoxels.Contains(GlobalCoord)) {&#10;      continue;&#10;    }&#10;&#10;    const FVoxelEntityData* EntityData = dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;        DataManager-&gt;GetVoxelData(GlobalCoord));&#10;&#10;    if (EntityData) {&#10;      MergeEntityChunk(GlobalCoord, *EntityData);&#10;    } else if (EntityToChunk.Contains(GlobalCoord)) {&#10;      SplitEntityChunk(GlobalCoord, ProcessedVoxels);&#10;    }&#10;&#10;    ProcessedVoxels.Add(GlobalCoord);&#10;  }&#10;&#10;  DirtyEntityVoxels = DirtyEntityVoxels.Difference(ProcessedVoxels);&#10;}&#10;&#10;void UEntityManager::MergeEntityChunk(const FIntVector&amp; GlobalCoord,&#10;                                      const FVoxelEntityData&amp; EntityData) {&#10;  if (EntityToChunk.Contains(GlobalCoord)) {&#10;    if (const TObjectPtr&lt;AEntityChunkActor&gt;* FoundEntityChunkActor =&#10;            EntityToChunk.Find(GlobalCoord)) {&#10;      const TObjectPtr&lt;AEntityChunkActor&gt; EntityChunkActor =&#10;          *FoundEntityChunkActor;&#10;&#10;      if (EntityChunkActor-&gt;IsChunkableWith(EntityData)) {&#10;        EntityChunkActor-&gt;OnEntityModified(GlobalCoord, EntityData);&#10;        return;&#10;      }&#10;&#10;      const TSet&lt;FIntVector&gt;&amp; RemainingCoords =&#10;          EntityChunkActor-&gt;GetEntityCoords();&#10;&#10;      EntityChunkActor-&gt;RemoveEntity(GlobalCoord);&#10;      EntityToChunk.Remove(GlobalCoord);&#10;&#10;      if (RemainingCoords.IsEmpty()) {&#10;        EntityChunks.Remove(EntityChunkActor);&#10;        EntityChunkActor-&gt;Destroy();&#10;      }&#10;    }&#10;  }&#10;&#10;  // 모든 방향에서 chunkable한 청크들 수집&#10;  TSet&lt;TObjectPtr&lt;AEntityChunkActor&gt;&gt; ChunkableMergeTargets;&#10;&#10;  for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;    const FIntVector NeighborCoord = GlobalCoord + Offset;&#10;    if (const TObjectPtr&lt;AEntityChunkActor&gt;* FoundChunk =&#10;            EntityToChunk.Find(NeighborCoord)) {&#10;      if ((*FoundChunk)-&gt;IsChunkableWith(EntityData)) {&#10;        ChunkableMergeTargets.Add(*FoundChunk);&#10;      }&#10;    }&#10;  }&#10;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; TargetChunk = nullptr;&#10;&#10;  if (ChunkableMergeTargets.Num() &gt; 0) {&#10;    // 첫 번째 청크를 타겟으로 선택&#10;    TargetChunk = *ChunkableMergeTargets.begin();&#10;    ChunkableMergeTargets.Remove(TargetChunk);&#10;&#10;    // 나머지 청크들을 타겟 청크로 병합&#10;    for (const TObjectPtr&lt;AEntityChunkActor&gt;&amp; ChunkToMerge : ChunkableMergeTargets) {&#10;      const TSet&lt;FIntVector&gt; EntitiesToMerge = ChunkToMerge-&gt;GetEntityCoords();&#10;      &#10;      // 병합할 청크의 모든 엔티티를 타겟 청크로 이동&#10;      for (const FIntVector&amp; EntityCoord : EntitiesToMerge) {&#10;        if (const FVoxelEntityData* VoxelEntityData =&#10;                dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                    DataManager-&gt;GetVoxelData(EntityCoord))) {&#10;          ChunkToMerge-&gt;RemoveEntity(EntityCoord);&#10;          TargetChunk-&gt;AddEntity(EntityCoord, *VoxelEntityData);&#10;          EntityToChunk[EntityCoord] = TargetChunk;&#10;        }&#10;      }&#10;      &#10;      // 병합된 청크 제거&#10;      EntityChunks.Remove(ChunkToMerge);&#10;      ChunkToMerge-&gt;Destroy();&#10;    }&#10;  } else {&#10;    // chunkable한 청크가 없으면 새 청크 생성&#10;    TargetChunk = GetEntityChunk(EntityData);&#10;  }&#10;&#10;  TargetChunk-&gt;AddEntity(GlobalCoord, EntityData);&#10;  EntityToChunk.Add(GlobalCoord, TargetChunk);&#10;}&#10;&#10;void UEntityManager::SplitEntityChunk(const FIntVector&amp; GlobalCoord,&#10;                                      TSet&lt;FIntVector&gt;&amp; ProcessedVoxels) {&#10;  const TObjectPtr&lt;AEntityChunkActor&gt;* FoundEntityChunkActor =&#10;      EntityToChunk.Find(GlobalCoord);&#10;  if (!FoundEntityChunkActor) {&#10;    return;&#10;  }&#10;&#10;  const TObjectPtr&lt;AEntityChunkActor&gt; EntityChunkActor = *FoundEntityChunkActor;&#10;  TSet&lt;FIntVector&gt; EntityCoords = EntityChunkActor-&gt;GetEntityCoords();&#10;&#10;  EntityChunkActor-&gt;RemoveEntity(GlobalCoord);&#10;  EntityToChunk.Remove(GlobalCoord);&#10;  EntityCoords.Remove(GlobalCoord);&#10;&#10;  if (EntityCoords.IsEmpty()) {&#10;    EntityChunks.Remove(EntityChunkActor);&#10;    EntityChunkActor-&gt;Destroy();&#10;    return;&#10;  }&#10;&#10;  EntityChunks.Remove(EntityChunkActor);&#10;&#10;  for (const FIntVector&amp; EntityCoord : EntityCoords) {&#10;    EntityToChunk.Remove(EntityCoord);&#10;  }&#10;&#10;  EntityChunkActor-&gt;Destroy();&#10;&#10;  for (const FIntVector&amp; VoxelCoord : EntityCoords) {&#10;    if (ProcessedVoxels.Contains(VoxelCoord)) {&#10;      continue;&#10;    }&#10;&#10;    if (const FVoxelEntityData* VoxelEntityData =&#10;            dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;      MergeEntityChunk(VoxelCoord, *VoxelEntityData);&#10;      ProcessedVoxels.Add(VoxelCoord);&#10;    }&#10;  }&#10;}&#10;&#10;UEntityManager::UEntityManager() {&#10;  bWantsInitializeComponent = true;&#10;}&#10;&#10;TObjectPtr&lt;AEntityChunkActor&gt; UEntityManager::GetEntityChunk(&#10;    const FVoxelEntityData&amp; EntityData) {&#10;  const TObjectPtr&lt;const UVoxelEntityDataAsset&gt; EntityDataAsset =&#10;      EntityData.GetEntityDataAsset();&#10;&#10;  if (!EntityDataAsset) {&#10;    return nullptr;&#10;  }&#10;&#10;  const TObjectPtr&lt;UWorld&gt; World = GetWorld();&#10;  if (!World) {&#10;    return nullptr;&#10;  }&#10;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; NewEntityChunkActor;&#10;&#10;  if (EntityDataAsset-&gt;EntityChunkActorClass) {&#10;    NewEntityChunkActor = World-&gt;SpawnActor&lt;AEntityChunkActor&gt;(&#10;        EntityDataAsset-&gt;EntityChunkActorClass);&#10;  } else {&#10;    NewEntityChunkActor = World-&gt;SpawnActor&lt;AEntityChunkActor&gt;();&#10;  }&#10;&#10;  EntityChunks.Add(NewEntityChunkActor);&#10;&#10;  return NewEntityChunkActor;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;Managers/EntityManager.h&quot;&#10;&#10;#include &quot;Actors/EntityChunkActor.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;&#10;void UEntityManager::InitializeComponent() {&#10;  Super::InitializeComponent();&#10;&#10;  if (const AActor* Owner = GetOwner()) {&#10;    DataManager = Owner-&gt;GetComponentByClass&lt;UDataManager&gt;();&#10;  }&#10;}&#10;&#10;void UEntityManager::SetDirtyEntity(const FIntVector&amp; GlobalCoord) {&#10;  DirtyEntityVoxels.Add(GlobalCoord);&#10;}&#10;&#10;void UEntityManager::OnEntityModified(const FIntVector&amp; GlobalCoord,&#10;                                      const FVoxelEntityData&amp; EntityData) {&#10;  if (const TObjectPtr&lt;AEntityChunkActor&gt;* FoundChunk =&#10;          EntityToChunk.Find(GlobalCoord)) {&#10;    (*FoundChunk)-&gt;OnEntityModified(GlobalCoord, EntityData);&#10;  }&#10;}&#10;&#10;void UEntityManager::FlushDirtyEntities() {&#10;  TSet&lt;FIntVector&gt; ProcessedVoxels;&#10;&#10;  for (const FIntVector&amp; GlobalCoord : DirtyEntityVoxels) {&#10;    if (ProcessedVoxels.Contains(GlobalCoord)) {&#10;      continue;&#10;    }&#10;&#10;    const FVoxelEntityData* EntityData = dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;        DataManager-&gt;GetVoxelData(GlobalCoord));&#10;&#10;    if (EntityData) {&#10;      MergeEntityChunk(GlobalCoord, *EntityData);&#10;    } else if (EntityToChunk.Contains(GlobalCoord)) {&#10;      SplitEntityChunk(GlobalCoord, ProcessedVoxels);&#10;    }&#10;&#10;    ProcessedVoxels.Add(GlobalCoord);&#10;  }&#10;&#10;  DirtyEntityVoxels = DirtyEntityVoxels.Difference(ProcessedVoxels);&#10;}&#10;&#10;void UEntityManager::MergeEntityChunk(const FIntVector&amp; GlobalCoord,&#10;                                      const FVoxelEntityData&amp; EntityData) {&#10;  if (EntityToChunk.Contains(GlobalCoord)) {&#10;    if (const TObjectPtr&lt;AEntityChunkActor&gt;* FoundEntityChunkActor =&#10;            EntityToChunk.Find(GlobalCoord)) {&#10;      const TObjectPtr&lt;AEntityChunkActor&gt; EntityChunkActor =&#10;          *FoundEntityChunkActor;&#10;&#10;      if (EntityChunkActor-&gt;IsChunkableWith(EntityData)) {&#10;        EntityChunkActor-&gt;OnEntityModified(GlobalCoord, EntityData);&#10;        return;&#10;      }&#10;&#10;      const TSet&lt;FIntVector&gt;&amp; RemainingCoords =&#10;          EntityChunkActor-&gt;GetEntityCoords();&#10;&#10;      EntityChunkActor-&gt;RemoveEntity(GlobalCoord);&#10;      EntityToChunk.Remove(GlobalCoord);&#10;&#10;      if (RemainingCoords.IsEmpty()) {&#10;        EntityChunks.Remove(EntityChunkActor);&#10;        EntityChunkActor-&gt;Destroy();&#10;      }&#10;    }&#10;  }&#10;&#10;  // 모든 방향에서 chunkable한 청크들 수집&#10;  TSet&lt;TObjectPtr&lt;AEntityChunkActor&gt;&gt; ChunkableMergeTargets;&#10;&#10;  for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;    const FIntVector NeighborCoord = GlobalCoord + Offset;&#10;    if (const TObjectPtr&lt;AEntityChunkActor&gt;* FoundChunk =&#10;            EntityToChunk.Find(NeighborCoord)) {&#10;      if ((*FoundChunk)-&gt;IsChunkableWith(EntityData)) {&#10;        ChunkableMergeTargets.Add(*FoundChunk);&#10;      }&#10;    }&#10;  }&#10;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; TargetChunk = nullptr;&#10;&#10;  if (ChunkableMergeTargets.Num() &gt; 0) {&#10;    // 첫 번째 청크를 타겟으로 선택&#10;    TargetChunk = *ChunkableMergeTargets.begin();&#10;    ChunkableMergeTargets.Remove(TargetChunk);&#10;&#10;    // 나머지 청크들을 타겟 청크로 병합&#10;    for (const TObjectPtr&lt;AEntityChunkActor&gt;&amp; ChunkToMerge : ChunkableMergeTargets) {&#10;      const TSet&lt;FIntVector&gt; EntitiesToMerge = ChunkToMerge-&gt;GetEntityCoords();&#10;      &#10;      // 병합할 청크의 모든 엔티티를 타겟 청크로 이동&#10;      for (const FIntVector&amp; EntityCoord : EntitiesToMerge) {&#10;        if (const FVoxelEntityData* VoxelEntityData =&#10;                dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                    DataManager-&gt;GetVoxelData(EntityCoord))) {&#10;          ChunkToMerge-&gt;RemoveEntity(EntityCoord);&#10;          TargetChunk-&gt;AddEntity(EntityCoord, *VoxelEntityData);&#10;          EntityToChunk[EntityCoord] = TargetChunk;&#10;        }&#10;      }&#10;      &#10;      // 병합된 청크 제거&#10;      EntityChunks.Remove(ChunkToMerge);&#10;      ChunkToMerge-&gt;Destroy();&#10;    }&#10;  } else {&#10;    // chunkable한 청크가 없으면 새 청크 생성&#10;    TargetChunk = GetEntityChunk(EntityData);&#10;  }&#10;&#10;  // 현재 엔티티를 타겟 청크에 추가&#10;  TargetChunk-&gt;AddEntity(GlobalCoord, EntityData);&#10;  EntityToChunk.Add(GlobalCoord, TargetChunk);&#10;}&#10;&#10;void UEntityManager::SplitEntityChunk(const FIntVector&amp; GlobalCoord,&#10;                                      TSet&lt;FIntVector&gt;&amp; ProcessedVoxels) {&#10;  const TObjectPtr&lt;AEntityChunkActor&gt;* FoundEntityChunkActor =&#10;      EntityToChunk.Find(GlobalCoord);&#10;  if (!FoundEntityChunkActor) {&#10;    return;&#10;  }&#10;&#10;  const TObjectPtr&lt;AEntityChunkActor&gt; EntityChunkActor = *FoundEntityChunkActor;&#10;  TSet&lt;FIntVector&gt; EntityCoords = EntityChunkActor-&gt;GetEntityCoords();&#10;&#10;  EntityChunkActor-&gt;RemoveEntity(GlobalCoord);&#10;  EntityToChunk.Remove(GlobalCoord);&#10;  EntityCoords.Remove(GlobalCoord);&#10;&#10;  if (EntityCoords.IsEmpty()) {&#10;    EntityChunks.Remove(EntityChunkActor);&#10;    EntityChunkActor-&gt;Destroy();&#10;    return;&#10;  }&#10;&#10;  EntityChunks.Remove(EntityChunkActor);&#10;&#10;  for (const FIntVector&amp; EntityCoord : EntityCoords) {&#10;    EntityToChunk.Remove(EntityCoord);&#10;  }&#10;&#10;  EntityChunkActor-&gt;Destroy();&#10;&#10;  for (const FIntVector&amp; VoxelCoord : EntityCoords) {&#10;    if (ProcessedVoxels.Contains(VoxelCoord)) {&#10;      continue;&#10;    }&#10;&#10;    if (const FVoxelEntityData* VoxelEntityData =&#10;            dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;      MergeEntityChunk(VoxelCoord, *VoxelEntityData);&#10;      ProcessedVoxels.Add(VoxelCoord);&#10;    }&#10;  }&#10;}&#10;&#10;UEntityManager::UEntityManager() {&#10;  bWantsInitializeComponent = true;&#10;}&#10;&#10;TObjectPtr&lt;AEntityChunkActor&gt; UEntityManager::GetEntityChunk(&#10;    const FVoxelEntityData&amp; EntityData) {&#10;  const TObjectPtr&lt;const UVoxelEntityDataAsset&gt; EntityDataAsset =&#10;      EntityData.GetEntityDataAsset();&#10;&#10;  if (!EntityDataAsset) {&#10;    return nullptr;&#10;  }&#10;&#10;  const TObjectPtr&lt;UWorld&gt; World = GetWorld();&#10;  if (!World) {&#10;    return nullptr;&#10;  }&#10;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; NewEntityChunkActor;&#10;&#10;  if (EntityDataAsset-&gt;EntityChunkActorClass) {&#10;    NewEntityChunkActor = World-&gt;SpawnActor&lt;AEntityChunkActor&gt;(&#10;        EntityDataAsset-&gt;EntityChunkActorClass);&#10;  } else {&#10;    NewEntityChunkActor = World-&gt;SpawnActor&lt;AEntityChunkActor&gt;();&#10;  }&#10;&#10;  EntityChunks.Add(NewEntityChunkActor);&#10;&#10;  return NewEntityChunkActor;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Components/SurfaceComponent.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Components/SurfaceComponent.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;class SurfaceComponent {&#10; public:&#10;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;Components/EntityComponent.h&quot;&#10;#include &quot;SurfaceComponent.generated.h&quot;&#10;&#10;UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))&#10;class VOXEL_API USurfaceComponent : public UEntityComponent {&#10;  GENERATED_BODY()&#10;&#10; public:&#10;  USurfaceComponent();&#10;&#10;  // 특정 지점으로부터 가장 가까운 표면 복셀 좌표 반환&#10;  UFUNCTION(BlueprintCallable, Category = &quot;Surface&quot;)&#10;  FIntVector GetClosestSurfaceVoxel(const FIntVector&amp; TargetCoord) const;&#10;&#10;  // 특정 지점으로부터 가장 가까운 표면 복셀까지의 거리 반환&#10;  UFUNCTION(BlueprintCallable, Category = &quot;Surface&quot;)&#10;  float GetDistanceToClosestSurface(const FIntVector&amp; TargetCoord) const;&#10;&#10;  // 표면 복셀 개수 반환&#10;  UFUNCTION(BlueprintCallable, Category = &quot;Surface&quot;)&#10;  int32 GetSurfaceVoxelCount() const { return SurfaceVoxels.Num(); }&#10;&#10;  // 모든 표면 복셀 좌표 반환&#10;  UFUNCTION(BlueprintCallable, Category = &quot;Surface&quot;)&#10;  const TSet&lt;FIntVector&gt;&amp; GetSurfaceVoxels() const { return SurfaceVoxels; }&#10;&#10;  // EntityComponent 오버라이드&#10;  virtual void OnEntityAdded(const FIntVector&amp; GlobalCoord,&#10;                           const FVoxelEntityData&amp; NewEntityData) override;&#10;  virtual void OnEntityRemoved(const FIntVector&amp; GlobalCoord) override;&#10;  virtual void OnEntityModified(const FIntVector&amp; GlobalCoord,&#10;                              const FVoxelEntityData&amp; NewEntityData) override;&#10;&#10; private:&#10;  // 표면 복셀들을 저장하는 세트&#10;  UPROPERTY()&#10;  TSet&lt;FIntVector&gt; SurfaceVoxels;&#10;&#10;  // 특정 복셀이 표면 복셀인지 확인&#10;  bool IsSurfaceVoxel(const FIntVector&amp; GlobalCoord) const;&#10;&#10;  // 표면 복셀 캐시를 업데이트&#10;  void UpdateSurfaceVoxels();&#10;&#10;  // 특정 복셀 주변의 표면 상태 업데이트&#10;  void UpdateSurfaceAroundVoxel(const FIntVector&amp; GlobalCoord);&#10;&#10;  // 인접 복셀 오프셋 (6방향)&#10;  static const TArray&lt;FIntVector&gt; NeighborOffsets;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Entity/Entity.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Entity/Entity.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Entity/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Entity/EntityChunk.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/EntityChunkComponent.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/EntityChunkComponent.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunkComponent.generated.h&quot;&#10;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS(Abstract, BlueprintType)&#10;class VOXEL_API UEntityChunkComponent : public UObject {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void OnEntityAdded(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {}&#10;  virtual void OnEntityRemoved(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {}&#10;  virtual void OnEntityModified(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {}&#10;  virtual void Tick(float DeltaTime) {}&#10;&#10;protected:&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UEntityChunk&gt; OwnerChunk;&#10;&#10;  friend class UEntityChunk;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Logic/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Logic/EntityChunk.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunk.generated.h&quot;&#10;&#10;class UEntityManager;&#10;&#10;UCLASS()&#10;class VOXEL_API UEntityChunk : public UObject&#10;{&#10;&#9;GENERATED_BODY()&#10;&#10;public:&#10;&#9;void Initialize(UEntityManager* InManager);&#10;&#9;void Tick(float DeltaTime);&#10;&#10;&#9;void AddVoxel(const FIntVector&amp; VoxelCoord);&#10;&#9;void RemoveVoxel(const FIntVector&amp; VoxelCoord);&#10;&#9;void MergeWith(UEntityChunk* OtherChunk);&#10;&#10;&#9;const TSet&lt;FIntVector&gt;&amp; GetVoxels() const;&#10;&#9;bool IsEmpty() const;&#10;&#10;&#9;// 이 청크에 속한 모든 복셀의 맵을 업데이트합니다.&#10;&#9;void UpdateVoxelMap();&#10;&#10;private:&#10;&#9;UPROPERTY()&#10;&#9;TSet&lt;FIntVector&gt; ManagedVoxels;&#10;&#10;&#9;UPROPERTY()&#10;&#9;TObjectPtr&lt;UEntityManager&gt; EntityManager;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Managers/DataManager.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Managers/DataManager.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;DataAssets/VoxelVoidDataAsset.h&quot;&#10;#include &quot;Voxel/Public/VoxelChunk.h&quot;&#10;&#10;#include &quot;DataManager.generated.h&quot;&#10;&#10;class UVoxelBlockDataAsset;&#10;class UMeshManager;&#10;class UDebugManager;&#10;class UVoxelBorderDataAsset;&#10;class UVoxelVoidDataAsset;&#10;class UVoxelBaseDataAsset;&#10;class AVoxelChunkActor;&#10;class UEntityManager;&#10;&#10;UCLASS()&#10;&#10;class VOXEL_API UDataManager : public UActorComponent {&#10;  GENERATED_BODY()&#10;&#10; public:&#10;  static float GetSurfaceLevel() { return 0.f; }&#10;&#10;  FVoxelChunk* GetVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;&#10;  inline const FVoxelBaseData* GetVoxelData(const FIntVector&amp; GlobalCoord);&#10;&#10;  void ModifyVoxelData(const FIntVector&amp; GlobalCoord,&#10;                       const TFunction&lt;void(FVoxelBaseData*)&gt;&amp; Modifier,&#10;                       bool bAutoDebug = true);&#10;&#10;  void SetVoxelData(const FIntVector&amp; GlobalCoord, FVoxelBaseData* NewVoxelData,&#10;                    bool bAutoDebug = true);&#10;&#10;  int32 GetChunkSize() const { return ChunkSize; }&#10;&#10;  int32 GetVoxelSize() const { return VoxelSize; }&#10;&#10;  inline FVector GlobalToWorldCoord(const FIntVector&amp; GlobalCoord) const;&#10;  inline FIntVector GlobalToChunkCoord(const FIntVector&amp; GlobalCoord) const;&#10;  inline FIntVector GlobalToLocalCoord(const FIntVector&amp; GlobalCoord) const;&#10;&#10;  inline FIntVector WorldToGlobalCoord(const FVector&amp; WorldCoord) const;&#10;  inline FIntVector ChunkToGlobalCoord(const FIntVector&amp; ChunkCoord) const;&#10;  inline FIntVector LocalToGlobalCoord(const FIntVector&amp; LocalCoord,&#10;                                       const FIntVector&amp; ChunkCoord) const;&#10;&#10;  inline int32 LocalCoordToIndex(const FIntVector&amp; LocalCoord) const;&#10;  inline int32 GlobalCoordToIndex(const FIntVector&amp; GlobalCoord) const;&#10;&#10; private:&#10;  UDataManager();&#10;&#10;  virtual void InitializeComponent() override;&#10;&#10;  FVoxelChunk* LoadVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;  void UnloadVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  int32 ChunkSize = 16;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  int32 VoxelSize = 50;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TObjectPtr&lt;UVoxelBlockDataAsset&gt; VoxelDefaultBlockDataAsset;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TSubclassOf&lt;AVoxelChunkActor&gt; VoxelChunkActorClass;&#10;&#10;  TMap&lt;FIntVector, FVoxelChunk&gt; VoxelChunks;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UDebugManager&gt; DebugManager;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UMeshManager&gt; MeshManager;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UEntityManager&gt; EntityManager;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;DataAssets/VoxelVoidDataAsset.h&quot;&#10;#include &quot;Voxel/Public/VoxelChunk.h&quot;&#10;&#10;#include &quot;DataManager.generated.h&quot;&#10;&#10;class UVoxelBlockDataAsset;&#10;class UMeshManager;&#10;class UDebugManager;&#10;class UVoxelBorderDataAsset;&#10;class UVoxelVoidDataAsset;&#10;class UVoxelBaseDataAsset;&#10;class AVoxelChunkActor;&#10;class UEntityManager;&#10;&#10;UCLASS()&#10;&#10;class VOXEL_API UDataManager : public UActorComponent {&#10;  GENERATED_BODY()&#10;&#10; public:&#10;  static float GetSurfaceLevel() { return 0.f; }&#10;&#10;  FVoxelChunk* GetVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;&#10;  inline const FVoxelBaseData* GetVoxelData(const FIntVector&amp; GlobalCoord);&#10;&#10;  void ModifyVoxelData(const FIntVector&amp; GlobalCoord,&#10;                       const TFunction&lt;void(FVoxelBaseData*)&gt;&amp; Modifier,&#10;                       bool bAutoDebug = true);&#10;&#10;  void SetVoxelData(const FIntVector&amp; GlobalCoord, FVoxelBaseData* NewVoxelData,&#10;                    bool bAutoDebug = true);&#10;&#10;  int32 GetChunkSize() const { return ChunkSize; }&#10;&#10;  int32 GetVoxelSize() const { return VoxelSize; }&#10;&#10;  inline FVector GlobalToWorldCoord(const FIntVector&amp; GlobalCoord) const;&#10;  inline FIntVector GlobalToChunkCoord(const FIntVector&amp; GlobalCoord) const;&#10;  inline FIntVector GlobalToLocalCoord(const FIntVector&amp; GlobalCoord) const;&#10;&#10;  inline FIntVector WorldToGlobalCoord(const FVector&amp; WorldCoord) const;&#10;  inline FIntVector ChunkToGlobalCoord(const FIntVector&amp; ChunkCoord) const;&#10;  inline FIntVector LocalToGlobalCoord(const FIntVector&amp; LocalCoord,&#10;                                       const FIntVector&amp; ChunkCoord) const;&#10;&#10;  inline int32 LocalCoordToIndex(const FIntVector&amp; LocalCoord) const;&#10;  inline int32 GlobalCoordToIndex(const FIntVector&amp; GlobalCoord) const;&#10;&#10; private:&#10;  UDataManager();&#10;&#10;  virtual void InitializeComponent() override;&#10;&#10;  FVoxelChunk* LoadVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;  void UnloadVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  int32 ChunkSize = 16;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  int32 VoxelSize = 50;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TObjectPtr&lt;UVoxelBlockDataAsset&gt; VoxelDefaultBlockDataAsset;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TSubclassOf&lt;AVoxelChunkActor&gt; VoxelChunkActorClass;&#10;&#10;  TMap&lt;FIntVector, FVoxelChunk&gt; VoxelChunks;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UDebugManager&gt; DebugManager;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UMeshManager&gt; MeshManager;&#10;&#10; public:&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;class UEntityManager&gt; EntityManager;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Managers/EntityManager.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Managers/EntityManager.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityManager.generated.h&quot;&#10;&#10;class AEntityChunkActor;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS()&#10;&#10;class VOXEL_API UEntityManager : public UActorComponent {&#10;  GENERATED_BODY()&#10;&#10;  const FIntVector NeighborOffsets[18] = {&#10;      FIntVector(1, 0, 0),   FIntVector(-1, 0, 0),  FIntVector(0, 1, 0),&#10;      FIntVector(0, -1, 0),  FIntVector(0, 0, 1),   FIntVector(0, 0, -1),&#10;&#10;      FIntVector(1, 1, 0),   FIntVector(1, -1, 0),  FIntVector(-1, 1, 0),&#10;      FIntVector(-1, -1, 0), FIntVector(1, 0, 1),   FIntVector(1, 0, -1),&#10;      FIntVector(-1, 0, 1),  FIntVector(-1, 0, -1), FIntVector(0, 1, 1),&#10;      FIntVector(0, 1, -1),  FIntVector(0, -1, 1),  FIntVector(0, -1, -1)};&#10;&#10; public:&#10;  void SetDirtyEntity(const FIntVector&amp; GlobalCoord);&#10;&#10;  void OnEntityModified(const FIntVector&amp; GlobalCoord,&#10;                        const FVoxelEntityData&amp; EntityData);&#10;&#10;  void FlushDirtyEntities();&#10;&#10; private:&#10;  UEntityManager();&#10;&#10;  virtual void InitializeComponent() override;&#10;&#10;  void MergeEntityChunk(const FIntVector&amp; GlobalCoord,&#10;                        const FVoxelEntityData&amp; EntityData,&#10;                        const TSet&lt;FIntVector&gt;&amp; ProcessedVoxels,&#10;                        TSet&lt;FIntVector&gt;&amp; MergedVoxels);&#10;&#10;  void SplitEntityChunk(const FIntVector&amp; GlobalCoord,&#10;                        const TSet&lt;FIntVector&gt;&amp; ProcessedVoxels,&#10;                        TSet&lt;FIntVector&gt;&amp; SplitVoxels);&#10;&#10;  bool GetChunkableEntityCoords(const FIntVector&amp; StartCoord,&#10;                                TSet&lt;FIntVector&gt;&amp; VisitedCoords,&#10;                                TSet&lt;FIntVector&gt;&amp; ChunkableEntityCoords) const;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; GetEntityChunk(&#10;      const FVoxelEntityData&amp; EntityData);&#10;&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UDataManager&gt; DataManager;&#10;&#10;  TMap&lt;FIntVector, TObjectPtr&lt;AEntityChunkActor&gt;&gt; EntityToChunk;&#10;&#10;  TSet&lt;TObjectPtr&lt;AEntityChunkActor&gt;&gt; EntityChunks;&#10;&#10;  TSet&lt;FIntVector&gt; DirtyEntityVoxels;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityManager.generated.h&quot;&#10;&#10;class AEntityChunkActor;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS()&#10;&#10;class VOXEL_API UEntityManager : public UActorComponent {&#10;  GENERATED_BODY()&#10;&#10;  const FIntVector NeighborOffsets[18] = {&#10;      FIntVector(1, 0, 0),   FIntVector(-1, 0, 0),  FIntVector(0, 1, 0),&#10;      FIntVector(0, -1, 0),  FIntVector(0, 0, 1),   FIntVector(0, 0, -1),&#10;&#10;      FIntVector(1, 1, 0),   FIntVector(1, -1, 0),  FIntVector(-1, 1, 0),&#10;      FIntVector(-1, -1, 0), FIntVector(1, 0, 1),   FIntVector(1, 0, -1),&#10;      FIntVector(-1, 0, 1),  FIntVector(-1, 0, -1), FIntVector(0, 1, 1),&#10;      FIntVector(0, 1, -1),  FIntVector(0, -1, 1),  FIntVector(0, -1, -1)};&#10;&#10; public:&#10;  void SetDirtyEntity(const FIntVector&amp; GlobalCoord);&#10;&#10;  void OnEntityModified(const FIntVector&amp; GlobalCoord,&#10;                        const FVoxelEntityData&amp; EntityData);&#10;&#10;  void FlushDirtyEntities();&#10;&#10; private:&#10;  UEntityManager();&#10;&#10;  virtual void InitializeComponent() override;&#10;&#10;  void MergeEntityChunk(const FIntVector&amp; GlobalCoord,&#10;                        const FVoxelEntityData&amp; EntityData,&#10;                        TSet&lt;FIntVector&gt;&amp; ProcessedVoxels);&#10;&#10;  void SplitEntityChunk(const FIntVector&amp; GlobalCoord,&#10;                        TSet&lt;FIntVector&gt;&amp; ProcessedVoxels);&#10;&#10;  // 더 이상 사용하지 않는 함수 (호환성을 위해 유지)&#10;  bool GetChunkableEntityCoords(const FIntVector&amp; StartCoord,&#10;                                TSet&lt;FIntVector&gt;&amp; VisitedCoords,&#10;                                TSet&lt;FIntVector&gt;&amp; ChunkableEntityCoords) const;&#10;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; GetEntityChunk(&#10;      const FVoxelEntityData&amp; EntityData);&#10;&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UDataManager&gt; DataManager;&#10;&#10;  TMap&lt;FIntVector, TObjectPtr&lt;AEntityChunkActor&gt;&gt; EntityToChunk;&#10;&#10;  TSet&lt;TObjectPtr&lt;AEntityChunkActor&gt;&gt; EntityChunks;&#10;&#10;  TSet&lt;FIntVector&gt; DirtyEntityVoxels;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>