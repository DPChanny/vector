<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Entity/Entity.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Entity/Entity.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Entity/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Entity/EntityChunk.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/EntityChunkComponent.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/EntityChunkComponent.cpp" />
              <option name="updatedContent" value="#include &quot;EntityChunkComponent.h&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Logic/EntityChunk.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Logic/EntityChunk.cpp" />
              <option name="updatedContent" value="#include &quot;Logic/EntityChunk.h&quot;&#10;#include &quot;Managers/EntityManager.h&quot;&#10;&#10;void UEntityChunk::Initialize(UEntityManager* InManager)&#10;{&#10;&#9;EntityManager = InManager;&#10;}&#10;&#10;void UEntityChunk::Tick(float DeltaTime)&#10;{&#10;&#9;// 이 청크에 대한 로직을 매 프레임 실행합니다. (예: 특정 액터 이동, 상태 변화 등)&#10;}&#10;&#10;void UEntityChunk::AddVoxel(const FIntVector&amp; VoxelCoord)&#10;{&#10;&#9;ManagedVoxels.Add(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::RemoveVoxel(const FIntVector&amp; VoxelCoord)&#10;{&#10;&#9;ManagedVoxels.Remove(VoxelCoord);&#10;}&#10;&#10;void UEntityChunk::MergeWith(UEntityChunk* OtherChunk)&#10;{&#10;&#9;if (!OtherChunk || OtherChunk == this) return;&#10;&#10;&#9;// 다른 청크의 복셀들을 현재 청크로 이동시킵니다.&#10;&#9;ManagedVoxels.Append(OtherChunk-&gt;GetVoxels());&#10;&#9;&#10;&#9;// 이동된 복셀들이 이제 현재 청크를 가리키도록 맵을 업데이트합니다.&#10;&#9;UpdateVoxelMap();&#10;}&#10;&#10;const TSet&lt;FIntVector&gt;&amp; UEntityChunk::GetVoxels() const&#10;{&#10;&#9;return ManagedVoxels;&#10;}&#10;&#10;bool UEntityChunk::IsEmpty() const&#10;{&#10;&#9;return ManagedVoxels.IsEmpty();&#10;}&#10;&#10;void UEntityChunk::UpdateVoxelMap()&#10;{&#10;&#9;if (EntityManager)&#10;&#9;{&#10;&#9;&#9;for (const FIntVector&amp; VoxelCoord : ManagedVoxels)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;EntityManager-&gt;UpdateVoxelChunkMapping(VoxelCoord, this);&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Managers/BuildManager.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Managers/BuildManager.cpp" />
              <option name="originalContent" value="#include &quot;Managers/BuildManager.h&quot;&#10;&#10;#include &quot;DataAssets/VoxelBlockDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelBorderDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelVoidDataAsset.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;#include &quot;Managers/MeshManager.h&quot;&#10;&#10;void UBuildManager::InitializeComponent() {&#10;  Super::InitializeComponent();&#10;&#10;  if (const AActor* Owner = GetOwner()) {&#10;    DataManager = Owner-&gt;GetComponentByClass&lt;UDataManager&gt;();&#10;    MeshManager = Owner-&gt;GetComponentByClass&lt;UMeshManager&gt;();&#10;  }&#10;}&#10;&#10;void UBuildManager::DamageBlocksInRadius(const FIntVector&amp; CenterGlobalCoord,&#10;                                         const float Radius,&#10;                                         const float DamageAmount) const {&#10;  auto DamageLogic = [&amp;](const FIntVector&amp; GlobalCoord) {&#10;    if (!DataManager) {&#10;      return;&#10;    }&#10;&#10;    const FVoxelBlockData* BlockData = dynamic_cast&lt;const FVoxelBlockData*&gt;(&#10;        DataManager-&gt;GetVoxelData(GlobalCoord));&#10;    if (!BlockData) {&#10;      return;&#10;    }&#10;&#10;    DataManager-&gt;ModifyVoxelData(&#10;        GlobalCoord, [DamageAmount](FVoxelBaseData* ModifierBaseData) {&#10;          dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData)-&gt;Durability -=&#10;              DamageAmount;&#10;        });&#10;&#10;    if (BlockData-&gt;Durability &lt;= 0) {&#10;      DataManager-&gt;SetVoxelData(GlobalCoord, new FVoxelVoidData());&#10;    }&#10;  };&#10;&#10;  ProcessVoxelsInRadius(CenterGlobalCoord, Radius, DamageLogic);&#10;}&#10;&#10;void UBuildManager::ConstructBlocksInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    const float ConstructionAmount,&#10;    const TObjectPtr&lt;const UVoxelBlockDataAsset&gt;&amp; NewVoxelBlockDataAsset,&#10;    const FVoxelBlockParams&amp; VoxelParams) const {&#10;  auto ConstructLogic = [&amp;](const FIntVector&amp; GlobalCoord) {&#10;    if (!DataManager) {&#10;      return;&#10;    }&#10;&#10;    const FVoxelBaseData* VoxelData = DataManager-&gt;GetVoxelData(GlobalCoord);&#10;&#10;    const FVoxelBlockData* BlockData =&#10;        dynamic_cast&lt;const FVoxelBlockData*&gt;(VoxelData);&#10;&#10;    if (BlockData) {&#10;      DataManager-&gt;ModifyVoxelData(&#10;          GlobalCoord, [ConstructionAmount](FVoxelBaseData* ModifierBaseData) {&#10;            dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData)-&gt;Durability +=&#10;                ConstructionAmount;&#10;          });&#10;    }&#10;&#10;    if ((BlockData &amp;&amp; BlockData-&gt;Durability &gt;&#10;                          BlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability) ||&#10;        FVoxelBorderData::IsBorder(VoxelData)) {&#10;&#10;      if (BlockData) {&#10;        DataManager-&gt;ModifyVoxelData(&#10;            GlobalCoord, [&amp;](FVoxelBaseData* ModifierBaseData) {&#10;              FVoxelBlockData* ModifierBlockData =&#10;                  dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData);&#10;              ModifierBlockData-&gt;Durability =&#10;                  ModifierBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;            });&#10;      }&#10;&#10;      for (const FIntVector&amp; NeighborOffset : NeighborOffsets) {&#10;        if (const FIntVector NeighborGlobalCoord = GlobalCoord + NeighborOffset;&#10;            FVoxelVoidData::IsVoid(&#10;                DataManager-&gt;GetVoxelData(NeighborGlobalCoord))) {&#10;&#10;          const TUniquePtr&lt;FVoxelBlockParams&gt; NewVoxelParams(&#10;              static_cast&lt;FVoxelBlockParams*&gt;(VoxelParams.Clone()));&#10;          NewVoxelParams-&gt;Durability = ConstructionAmount;&#10;&#10;          if (FVoxelBaseData* NewVoxelData =&#10;                  NewVoxelBlockDataAsset-&gt;ConstructVoxelData(*NewVoxelParams)) {&#10;            DataManager-&gt;SetVoxelData(NeighborGlobalCoord, NewVoxelData);&#10;          }&#10;&#10;          for (const FIntVector&amp; CheckOffset : NeighborOffsets) {&#10;            const FIntVector CheckGlobalCoord =&#10;                NeighborGlobalCoord + CheckOffset;&#10;            if (CheckGlobalCoord == GlobalCoord) {&#10;              continue;&#10;            }&#10;&#10;            if (!IsSurfaceVoxel(CheckGlobalCoord)) {&#10;              DataManager-&gt;ModifyVoxelData(&#10;                  CheckGlobalCoord, [&amp;](FVoxelBaseData* CheckVoxelData) {&#10;                    if (FVoxelBlockData* CheckBlockData =&#10;                            dynamic_cast&lt;FVoxelBlockData*&gt;(CheckVoxelData)) {&#10;                      CheckBlockData-&gt;Durability =&#10;                          CheckBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;                    }&#10;                  });&#10;            }&#10;          }&#10;&#10;          if (!IsSurfaceVoxel(NeighborGlobalCoord)) {&#10;            DataManager-&gt;ModifyVoxelData(&#10;                NeighborGlobalCoord, [&amp;](FVoxelBaseData* NeighborVoxelData) {&#10;                  if (FVoxelBlockData* NeighborBlockData =&#10;                          dynamic_cast&lt;FVoxelBlockData*&gt;(NeighborVoxelData)) {&#10;                    NeighborBlockData-&gt;Durability =&#10;                        NeighborBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;                  }&#10;                });&#10;          }&#10;        }&#10;      }&#10;    }&#10;  };&#10;&#10;  ProcessVoxelsInRadius(CenterGlobalCoord, Radius, ConstructLogic);&#10;}&#10;&#10;void UBuildManager::GetGlobalCoordsInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    TSet&lt;FIntVector&gt;&amp; FoundGlobalCoords) const {&#10;  if (!DataManager) {&#10;    return;&#10;  }&#10;&#10;  const int32 RadiusInVoxels =&#10;      FMath::CeilToInt(Radius / DataManager-&gt;GetVoxelSize());&#10;  const int32 RadiusSquared = FMath::Square(RadiusInVoxels);&#10;&#10;  for (int32 z = -RadiusInVoxels; z &lt;= RadiusInVoxels; ++z) {&#10;    for (int32 y = -RadiusInVoxels; y &lt;= RadiusInVoxels; ++y) {&#10;      for (int32 x = -RadiusInVoxels; x &lt;= RadiusInVoxels; ++x) {&#10;        if (const int32 DistanceSquared = x * x + y * y + z * z;&#10;            DistanceSquared &lt;= RadiusSquared) {&#10;          const FIntVector GlobalCoord =&#10;              CenterGlobalCoord + FIntVector(x, y, z);&#10;          FoundGlobalCoords.Add(GlobalCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;UBuildManager::UBuildManager() {&#10;  bWantsInitializeComponent = true;&#10;}&#10;&#10;void UBuildManager::ProcessVoxelsInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    const TFunction&lt;void(const FIntVector&amp;)&gt;&amp; VoxelModifier) const {&#10;  if (!MeshManager || !DataManager) {&#10;    return;&#10;  }&#10;&#10;  TSet&lt;FIntVector&gt; GlobalCoordsInRadius;&#10;  GetGlobalCoordsInRadius(CenterGlobalCoord, Radius, GlobalCoordsInRadius);&#10;&#10;  TSet&lt;FIntVector&gt; GlobalCoordsToProcess;&#10;  TQueue&lt;FIntVector&gt; Queue;&#10;  TSet&lt;FIntVector&gt; Visited;&#10;&#10;  Queue.Enqueue(CenterGlobalCoord);&#10;  Visited.Add(CenterGlobalCoord);&#10;&#10;  while (!Queue.IsEmpty()) {&#10;    FIntVector CurrentGlobalCoord;&#10;    Queue.Dequeue(CurrentGlobalCoord);&#10;&#10;    if (IsSurfaceVoxel(CurrentGlobalCoord)) {&#10;      GlobalCoordsToProcess.Add(CurrentGlobalCoord);&#10;    }&#10;&#10;    for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;      const FIntVector NeighborCoord = CurrentGlobalCoord + Offset;&#10;&#10;      if (Visited.Contains(NeighborCoord) ||&#10;          !GlobalCoordsInRadius.Contains(NeighborCoord)) {&#10;        continue;&#10;      }&#10;&#10;      if (!FVoxelVoidData::IsVoid(DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;        Queue.Enqueue(NeighborCoord);&#10;        Visited.Add(NeighborCoord);&#10;      } else {&#10;        Visited.Add(NeighborCoord);&#10;      }&#10;    }&#10;  }&#10;&#10;  for (const FIntVector&amp; VoxelCoord : GlobalCoordsToProcess) {&#10;    VoxelModifier(VoxelCoord);&#10;  }&#10;&#10;  MeshManager-&gt;FlushDirtyChunks();&#10;}&#10;&#10;bool UBuildManager::IsSurfaceVoxel(const FIntVector&amp; VoxelCoord) const {&#10;  if (!DataManager) {&#10;    return false;&#10;  }&#10;&#10;  for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;    if (FVoxelVoidData::IsVoid(&#10;            DataManager-&gt;GetVoxelData(VoxelCoord + Offset))) {&#10;      return true;&#10;    }&#10;  }&#10;  return false;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;Managers/BuildManager.h&quot;&#10;&#10;#include &quot;DataAssets/VoxelBlockDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelBorderDataAsset.h&quot;&#10;#include &quot;DataAssets/VoxelVoidDataAsset.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;#include &quot;Managers/MeshManager.h&quot;&#10;&#10;void UBuildManager::InitializeComponent() {&#10;  Super::InitializeComponent();&#10;&#10;  if (const AActor* Owner = GetOwner()) {&#10;    DataManager = Owner-&gt;GetComponentByClass&lt;UDataManager&gt;();&#10;    MeshManager = Owner-&gt;GetComponentByClass&lt;UMeshManager&gt;();&#10;  }&#10;}&#10;&#10;void UBuildManager::DamageBlocksInRadius(const FIntVector&amp; CenterGlobalCoord,&#10;                                         const float Radius,&#10;                                         const float DamageAmount) const {&#10;  auto DamageLogic = [&amp;](const FIntVector&amp; GlobalCoord) {&#10;    if (!DataManager) {&#10;      return;&#10;    }&#10;&#10;    const FVoxelBlockData* BlockData = dynamic_cast&lt;const FVoxelBlockData*&gt;(&#10;        DataManager-&gt;GetVoxelData(GlobalCoord));&#10;    if (!BlockData) {&#10;      return;&#10;    }&#10;&#10;    DataManager-&gt;ModifyVoxelData(&#10;        GlobalCoord, [DamageAmount](FVoxelBaseData* ModifierBaseData) {&#10;          dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData)-&gt;Durability -=&#10;              DamageAmount;&#10;        });&#10;&#10;    if (BlockData-&gt;Durability &lt;= 0) {&#10;      DataManager-&gt;SetVoxelData(GlobalCoord, new FVoxelVoidData());&#10;    }&#10;  };&#10;&#10;  ProcessVoxelsInRadius(CenterGlobalCoord, Radius, DamageLogic);&#10;}&#10;&#10;void UBuildManager::ConstructBlocksInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    const float ConstructionAmount,&#10;    const TObjectPtr&lt;const UVoxelBlockDataAsset&gt;&amp; NewVoxelBlockDataAsset,&#10;    const FVoxelBlockParams&amp; VoxelParams) const {&#10;  auto ConstructLogic = [&amp;](const FIntVector&amp; GlobalCoord) {&#10;    if (!DataManager) {&#10;      return;&#10;    }&#10;&#10;    const FVoxelBaseData* VoxelData = DataManager-&gt;GetVoxelData(GlobalCoord);&#10;&#10;    const FVoxelBlockData* BlockData =&#10;        dynamic_cast&lt;const FVoxelBlockData*&gt;(VoxelData);&#10;&#10;    if (BlockData) {&#10;      DataManager-&gt;ModifyVoxelData(&#10;          GlobalCoord, [ConstructionAmount](FVoxelBaseData* ModifierBaseData) {&#10;            dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData)-&gt;Durability +=&#10;                ConstructionAmount;&#10;          });&#10;    }&#10;&#10;    if ((BlockData &amp;&amp; BlockData-&gt;Durability &gt;&#10;                          BlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability) ||&#10;        FVoxelBorderData::IsBorder(VoxelData)) {&#10;&#10;      if (BlockData) {&#10;        DataManager-&gt;ModifyVoxelData(&#10;            GlobalCoord, [&amp;](FVoxelBaseData* ModifierBaseData) {&#10;              FVoxelBlockData* ModifierBlockData =&#10;                  dynamic_cast&lt;FVoxelBlockData*&gt;(ModifierBaseData);&#10;              ModifierBlockData-&gt;Durability =&#10;                  ModifierBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;            });&#10;      }&#10;&#10;      for (const FIntVector&amp; NeighborOffset : NeighborOffsets) {&#10;        if (const FIntVector NeighborGlobalCoord = GlobalCoord + NeighborOffset;&#10;            FVoxelVoidData::IsVoid(&#10;                DataManager-&gt;GetVoxelData(NeighborGlobalCoord))) {&#10;&#10;          const TUniquePtr&lt;FVoxelBlockParams&gt; NewVoxelParams(&#10;              static_cast&lt;FVoxelBlockParams*&gt;(VoxelParams.Clone()));&#10;          NewVoxelParams-&gt;Durability = ConstructionAmount;&#10;&#10;          if (FVoxelBaseData* NewVoxelData =&#10;                  NewVoxelBlockDataAsset-&gt;ConstructVoxelData(*NewVoxelParams)) {&#10;            DataManager-&gt;SetVoxelData(NeighborGlobalCoord, NewVoxelData);&#10;          }&#10;&#10;          for (const FIntVector&amp; CheckOffset : NeighborOffsets) {&#10;            const FIntVector CheckGlobalCoord =&#10;                NeighborGlobalCoord + CheckOffset;&#10;            if (CheckGlobalCoord == GlobalCoord) {&#10;              continue;&#10;            }&#10;&#10;            if (!IsSurfaceVoxel(CheckGlobalCoord)) {&#10;              DataManager-&gt;ModifyVoxelData(&#10;                  CheckGlobalCoord, [&amp;](FVoxelBaseData* CheckVoxelData) {&#10;                    if (FVoxelBlockData* CheckBlockData =&#10;                            dynamic_cast&lt;FVoxelBlockData*&gt;(CheckVoxelData)) {&#10;                      CheckBlockData-&gt;Durability =&#10;                          CheckBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;                    }&#10;                  });&#10;            }&#10;          }&#10;&#10;          if (!IsSurfaceVoxel(NeighborGlobalCoord)) {&#10;            DataManager-&gt;ModifyVoxelData(&#10;                NeighborGlobalCoord, [&amp;](FVoxelBaseData* NeighborVoxelData) {&#10;                  if (FVoxelBlockData* NeighborBlockData =&#10;                          dynamic_cast&lt;FVoxelBlockData*&gt;(NeighborVoxelData)) {&#10;                    NeighborBlockData-&gt;Durability =&#10;                        NeighborBlockData-&gt;GetBlockDataAsset()-&gt;MaxDurability;&#10;                  }&#10;                });&#10;          }&#10;        }&#10;      }&#10;    }&#10;  };&#10;&#10;  ProcessVoxelsInRadius(CenterGlobalCoord, Radius, ConstructLogic);&#10;}&#10;&#10;void UBuildManager::GetGlobalCoordsInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    TSet&lt;FIntVector&gt;&amp; FoundGlobalCoords) const {&#10;  if (!DataManager) {&#10;    return;&#10;  }&#10;&#10;  const int32 RadiusInVoxels =&#10;      FMath::CeilToInt(Radius / DataManager-&gt;GetVoxelSize());&#10;  const int32 RadiusSquared = FMath::Square(RadiusInVoxels);&#10;&#10;  for (int32 z = -RadiusInVoxels; z &lt;= RadiusInVoxels; ++z) {&#10;    for (int32 y = -RadiusInVoxels; y &lt;= RadiusInVoxels; ++y) {&#10;      for (int32 x = -RadiusInVoxels; x &lt;= RadiusInVoxels; ++x) {&#10;        if (const int32 DistanceSquared = x * x + y * y + z * z;&#10;            DistanceSquared &lt;= RadiusSquared) {&#10;          const FIntVector GlobalCoord =&#10;              CenterGlobalCoord + FIntVector(x, y, z);&#10;          FoundGlobalCoords.Add(GlobalCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;UBuildManager::UBuildManager() {&#10;  bWantsInitializeComponent = true;&#10;}&#10;&#10;void UBuildManager::ProcessVoxelsInRadius(&#10;    const FIntVector&amp; CenterGlobalCoord, const float Radius,&#10;    const TFunction&lt;void(const FIntVector&amp;)&gt;&amp; VoxelModifier) const {&#10;  if (!MeshManager || !DataManager) {&#10;    return;&#10;  }&#10;&#10;  TSet&lt;FIntVector&gt; GlobalCoordsInRadius;&#10;  GetGlobalCoordsInRadius(CenterGlobalCoord, Radius, GlobalCoordsInRadius);&#10;&#10;  TSet&lt;FIntVector&gt; GlobalCoordsToProcess;&#10;  TQueue&lt;FIntVector&gt; Queue;&#10;  TSet&lt;FIntVector&gt; Visited;&#10;&#10;  Queue.Enqueue(CenterGlobalCoord);&#10;  Visited.Add(CenterGlobalCoord);&#10;&#10;  while (!Queue.IsEmpty()) {&#10;    FIntVector CurrentGlobalCoord;&#10;    Queue.Dequeue(CurrentGlobalCoord);&#10;&#10;    if (IsSurfaceVoxel(CurrentGlobalCoord)) {&#10;      GlobalCoordsToProcess.Add(CurrentGlobalCoord);&#10;    }&#10;&#10;    for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;      const FIntVector NeighborCoord = CurrentGlobalCoord + Offset;&#10;&#10;      if (Visited.Contains(NeighborCoord) ||&#10;          !GlobalCoordsInRadius.Contains(NeighborCoord)) {&#10;        continue;&#10;      }&#10;&#10;      if (!FVoxelVoidData::IsVoid(DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;        Queue.Enqueue(NeighborCoord);&#10;        Visited.Add(NeighborCoord);&#10;      } else {&#10;        Visited.Add(NeighborCoord);&#10;      }&#10;    }&#10;  }&#10;&#10;  for (const FIntVector&amp; VoxelCoord : GlobalCoordsToProcess) {&#10;    VoxelModifier(VoxelCoord);&#10;  }&#10;&#10;  MeshManager-&gt;FlushDirtyChunks();&#10;&#10;  // 엔티티 병합/분할 처리&#10;  if (DataManager &amp;&amp; DataManager-&gt;EntityManager) {&#10;    DataManager-&gt;EntityManager-&gt;FlushDirtyEntities();&#10;  }&#10;}&#10;&#10;bool UBuildManager::IsSurfaceVoxel(const FIntVector&amp; VoxelCoord) const {&#10;  if (!DataManager) {&#10;    return false;&#10;  }&#10;&#10;  for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;    if (FVoxelVoidData::IsVoid(&#10;            DataManager-&gt;GetVoxelData(VoxelCoord + Offset))) {&#10;      return true;&#10;    }&#10;  }&#10;  return false;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Private/Managers/EntityManager.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Private/Managers/EntityManager.cpp" />
              <option name="originalContent" value="#include &quot;Managers/EntityManager.h&quot;&#10;&#10;#include &quot;Actors/EntityChunkActor.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;&#10;void UEntityManager::InitializeComponent() {&#10;  Super::InitializeComponent();&#10;&#10;  if (const AActor* Owner = GetOwner()) {&#10;    DataManager = Owner-&gt;GetComponentByClass&lt;UDataManager&gt;();&#10;  }&#10;}&#10;&#10;void UEntityManager::SetDirtyEntity(const FIntVector&amp; GlobalCoord) {&#10;  DirtyEntityVoxels.Add(GlobalCoord);&#10;}&#10;&#10;void UEntityManager::OnEntityModified(const FIntVector&amp; GlobalCoord,&#10;                                      const FVoxelEntityData&amp; EntityData) {&#10;  if (const TObjectPtr&lt;AEntityChunkActor&gt;* FoundChunk =&#10;          EntityToChunk.Find(GlobalCoord)) {&#10;    (*FoundChunk)-&gt;OnEntityModified(GlobalCoord, EntityData);&#10;  }&#10;}&#10;&#10;void UEntityManager::FlushDirtyEntities() {&#10;  TSet&lt;FIntVector&gt; ToProcess = DirtyEntityVoxels;&#10;  DirtyEntityVoxels.Empty();&#10;&#10;  for (const FIntVector&amp; GlobalCoord : ToProcess) {&#10;    const FVoxelEntityData* EntityData = dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;        DataManager-&gt;GetVoxelData(GlobalCoord));&#10;  }&#10;}&#10;&#10;UEntityManager::UEntityManager() {&#10;  bWantsInitializeComponent = true;&#10;}&#10;&#10;TObjectPtr&lt;AEntityChunkActor&gt; UEntityManager::GetEntityChunk(&#10;    const FVoxelEntityData&amp; EntityData) {&#10;  const TObjectPtr&lt;const UVoxelEntityDataAsset&gt; EntityDataAsset =&#10;      EntityData.GetEntityDataAsset();&#10;&#10;  if (!EntityDataAsset) {&#10;    return nullptr;&#10;  }&#10;&#10;  const TObjectPtr&lt;UWorld&gt; World = GetWorld();&#10;  if (!World) {&#10;    return nullptr;&#10;  }&#10;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; NewEntityChunkActor;&#10;&#10;  if (EntityDataAsset-&gt;EntityChunkActorClass) {&#10;    NewEntityChunkActor = World-&gt;SpawnActor&lt;AEntityChunkActor&gt;(&#10;        EntityDataAsset-&gt;EntityChunkActorClass);&#10;  } else {&#10;    NewEntityChunkActor = World-&gt;SpawnActor&lt;AEntityChunkActor&gt;();&#10;  }&#10;&#10;  EntityChunks.Add(NewEntityChunkActor);&#10;&#10;  return NewEntityChunkActor;&#10;}&#10;&#10;void UEntityManager::UpdateEntityChunk(&#10;    const TObjectPtr&lt;AEntityChunkActor&gt;&amp; OriginalChunk) {&#10;  TArray&lt;FIntVector&gt; OriginalVoxels = OriginalChunk-&gt;GetEntities().Array();&#10;&#10;  for (const FIntVector&amp; VoxelCoord : OriginalVoxels) {&#10;    if (const FVoxelEntityData* EntityData =&#10;            dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;      OriginalChunk-&gt;RemoveEntity(VoxelCoord, *EntityData);&#10;    }&#10;    EntityToChunk.Remove(VoxelCoord);&#10;  }&#10;&#10;  EntityChunks.Remove(OriginalChunk);&#10;  OriginalChunk-&gt;Destroy();&#10;&#10;  TSet&lt;FIntVector&gt; VisitedVoxels;&#10;&#10;  for (const FIntVector&amp; VoxelCoord : OriginalVoxels) {&#10;    if (VisitedVoxels.Contains(VoxelCoord)) {&#10;      continue;&#10;    }&#10;&#10;    if (TSet&lt;FIntVector&gt; ChunkableVoxels;&#10;        GetChunkableEntityCoords(VoxelCoord, VisitedVoxels, ChunkableVoxels)) {&#10;      if (const FVoxelEntityData* EntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                  DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;        TObjectPtr&lt;AEntityChunkActor&gt; NewChunk = GetEntityChunk(*EntityData);&#10;&#10;        for (const FIntVector&amp; ChunkableVoxel : ChunkableVoxels) {&#10;          if (const FVoxelEntityData* VoxelEntityData =&#10;                  dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                      DataManager-&gt;GetVoxelData(ChunkableVoxel))) {&#10;            NewChunk-&gt;AddEntity(ChunkableVoxel, *VoxelEntityData);&#10;            EntityToChunk.Add(ChunkableVoxel, NewChunk);&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;bool UEntityManager::GetChunkableEntityCoords(&#10;    const FIntVector&amp; StartCoord, TSet&lt;FIntVector&gt;&amp; VisitedCoords,&#10;    TSet&lt;FIntVector&gt;&amp; ChunkableEntityCoords) const {&#10;  ChunkableEntityCoords.Reset();&#10;  TQueue&lt;FIntVector&gt; ToVisit;&#10;&#10;  const FVoxelEntityData* StartEntityData =&#10;      dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;          DataManager-&gt;GetVoxelData(StartCoord));&#10;&#10;  if (!StartEntityData) {&#10;    return false;&#10;  }&#10;&#10;  ToVisit.Enqueue(StartCoord);&#10;&#10;  while (!ToVisit.IsEmpty()) {&#10;    FIntVector CurrentCoord;&#10;    ToVisit.Dequeue(CurrentCoord);&#10;&#10;    if (VisitedCoords.Contains(CurrentCoord)) {&#10;      continue;&#10;    }&#10;&#10;    const FVoxelEntityData* CurrentEntityData =&#10;        dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;            DataManager-&gt;GetVoxelData(CurrentCoord));&#10;&#10;    if (!CurrentEntityData ||&#10;        !StartEntityData-&gt;IsChunkableWith(CurrentEntityData)) {&#10;      continue;&#10;    }&#10;&#10;    VisitedCoords.Add(CurrentCoord);&#10;    ChunkableEntityCoords.Add(CurrentCoord);&#10;&#10;    for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;      if (const FIntVector NeighborCoord = CurrentCoord + Offset;&#10;          !VisitedCoords.Contains(NeighborCoord)) {&#10;        if (FVoxelEntityData::IsEntity(&#10;                DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;          ToVisit.Enqueue(NeighborCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  return !ChunkableEntityCoords.IsEmpty();&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;Managers/EntityManager.h&quot;&#10;&#10;#include &quot;Actors/EntityChunkActor.h&quot;&#10;#include &quot;DataAssets/VoxelEntityDataAsset.h&quot;&#10;#include &quot;Managers/DataManager.h&quot;&#10;&#10;void UEntityManager::InitializeComponent() {&#10;  Super::InitializeComponent();&#10;&#10;  if (const AActor* Owner = GetOwner()) {&#10;    DataManager = Owner-&gt;GetComponentByClass&lt;UDataManager&gt;();&#10;  }&#10;}&#10;&#10;void UEntityManager::SetDirtyEntity(const FIntVector&amp; GlobalCoord) {&#10;  DirtyEntityVoxels.Add(GlobalCoord);&#10;}&#10;&#10;void UEntityManager::OnEntityModified(const FIntVector&amp; GlobalCoord,&#10;                                      const FVoxelEntityData&amp; EntityData) {&#10;  if (const TObjectPtr&lt;AEntityChunkActor&gt;* FoundChunk =&#10;          EntityToChunk.Find(GlobalCoord)) {&#10;    (*FoundChunk)-&gt;OnEntityModified(GlobalCoord, EntityData);&#10;  }&#10;}&#10;&#10;void UEntityManager::FlushDirtyEntities() {&#10;  TSet&lt;FIntVector&gt; ProcessedVoxels;&#10;&#10;  for (const FIntVector&amp; GlobalCoord : DirtyEntityVoxels) {&#10;    if (ProcessedVoxels.Contains(GlobalCoord)) {&#10;      continue;&#10;    }&#10;&#10;    const FVoxelEntityData* EntityData = dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;        DataManager-&gt;GetVoxelData(GlobalCoord));&#10;&#10;    if (EntityData) {&#10;      // 엔티티 존재: 병합 수행&#10;      TSet&lt;FIntVector&gt; MergedVoxels;&#10;      PerformEntityMerge(GlobalCoord, *EntityData, ProcessedVoxels, MergedVoxels);&#10;      ProcessedVoxels.Append(MergedVoxels);&#10;    } else {&#10;      // 엔티티 파괴: 분할 수행&#10;      TSet&lt;FIntVector&gt; SplitVoxels;&#10;      PerformEntitySplit(GlobalCoord, ProcessedVoxels, SplitVoxels);&#10;      ProcessedVoxels.Append(SplitVoxels);&#10;    }&#10;  }&#10;&#10;  // 처리된 좌표들을 DirtyEntityVoxels에서 제거&#10;  DirtyEntityVoxels = DirtyEntityVoxels.Difference(ProcessedVoxels);&#10;}&#10;&#10;void UEntityManager::PerformEntityMerge(const FIntVector&amp; GlobalCoord,&#10;                                        const FVoxelEntityData&amp; EntityData,&#10;                                        const TSet&lt;FIntVector&gt;&amp; ProcessedVoxels,&#10;                                        TSet&lt;FIntVector&gt;&amp; MergedVoxels) {&#10;  // 이미 청크에 속해있으면 병합 불필요&#10;  if (EntityToChunk.Contains(GlobalCoord)) {&#10;    MergedVoxels.Add(GlobalCoord);&#10;    return;&#10;  }&#10;&#10;  // 인접한 같은 타입 엔티티들과 병합 가능한 청크 찾기&#10;  TObjectPtr&lt;AEntityChunkActor&gt; TargetChunk = nullptr;&#10;  TSet&lt;FIntVector&gt; ChunkableVoxels;&#10;  TSet&lt;FIntVector&gt; VisitedVoxels;&#10;&#10;  // 인접 청크 중 병합 가능한 청크 찾기&#10;  for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;    const FIntVector NeighborCoord = GlobalCoord + Offset;&#10;    if (const TObjectPtr&lt;AEntityChunkActor&gt;* FoundChunk = EntityToChunk.Find(NeighborCoord)) {&#10;      if ((*FoundChunk)-&gt;CanMergeWith(EntityData)) {&#10;        TargetChunk = *FoundChunk;&#10;        break;&#10;      }&#10;    }&#10;  }&#10;&#10;  // 병합 가능한 청크가 없으면 새 청크 생성&#10;  if (!TargetChunk) {&#10;    TargetChunk = GetEntityChunk(EntityData);&#10;  }&#10;&#10;  // 연결된 엔티티들 찾기&#10;  if (GetChunkableEntityCoords(GlobalCoord, VisitedVoxels, ChunkableVoxels)) {&#10;    // 기존 청크들에서 제거할 엔티티들 수집&#10;    TMap&lt;TObjectPtr&lt;AEntityChunkActor&gt;, TSet&lt;FIntVector&gt;&gt; ChunksToUpdate;&#10;&#10;    for (const FIntVector&amp; VoxelCoord : ChunkableVoxels) {&#10;      if (ProcessedVoxels.Contains(VoxelCoord)) continue;&#10;&#10;      if (const TObjectPtr&lt;AEntityChunkActor&gt;* ExistingChunk = EntityToChunk.Find(VoxelCoord)) {&#10;        if (*ExistingChunk != TargetChunk) {&#10;          ChunksToUpdate.FindOrAdd(*ExistingChunk).Add(VoxelCoord);&#10;        }&#10;      }&#10;    }&#10;&#10;    // 기존 청크들에서 엔티티 제거&#10;    for (const auto&amp; [ChunkToUpdate, VoxelsToRemove] : ChunksToUpdate) {&#10;      for (const FIntVector&amp; VoxelCoord : VoxelsToRemove) {&#10;        if (const FVoxelEntityData* VoxelEntityData =&#10;            dynamic_cast&lt;const FVoxelEntityData*&gt;(DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;          ChunkToUpdate-&gt;RemoveEntity(VoxelCoord, *VoxelEntityData);&#10;          EntityToChunk.Remove(VoxelCoord);&#10;        }&#10;      }&#10;&#10;      // 빈 청크 제거&#10;      if (ChunkToUpdate-&gt;IsEmpty()) {&#10;        EntityChunks.Remove(ChunkToUpdate);&#10;        ChunkToUpdate-&gt;Destroy();&#10;      }&#10;    }&#10;&#10;    // 타겟 청크에 엔티티들 추가&#10;    for (const FIntVector&amp; VoxelCoord : ChunkableVoxels) {&#10;      if (ProcessedVoxels.Contains(VoxelCoord)) continue;&#10;&#10;      if (const FVoxelEntityData* VoxelEntityData =&#10;          dynamic_cast&lt;const FVoxelEntityData*&gt;(DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;        TargetChunk-&gt;AddEntity(VoxelCoord, *VoxelEntityData);&#10;        EntityToChunk.Add(VoxelCoord, TargetChunk);&#10;      }&#10;    }&#10;&#10;    MergedVoxels = ChunkableVoxels;&#10;  }&#10;}&#10;&#10;void UEntityManager::PerformEntitySplit(const FIntVector&amp; GlobalCoord,&#10;                                        const TSet&lt;FIntVector&gt;&amp; ProcessedVoxels,&#10;                                        TSet&lt;FIntVector&gt;&amp; SplitVoxels) {&#10;  // 해당 좌표의 청크 찾기&#10;  const TObjectPtr&lt;AEntityChunkActor&gt;* FoundChunk = EntityToChunk.Find(GlobalCoord);&#10;  if (!FoundChunk) {&#10;    SplitVoxels.Add(GlobalCoord);&#10;    return;&#10;  }&#10;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; OriginalChunk = *FoundChunk;&#10;  TSet&lt;FIntVector&gt; OriginalVoxels = OriginalChunk-&gt;GetEntities();&#10;&#10;  // 파괴된 엔티티 제거&#10;  if (const FVoxelEntityData* EntityData =&#10;      dynamic_cast&lt;const FVoxelEntityData*&gt;(DataManager-&gt;GetVoxelData(GlobalCoord))) {&#10;    OriginalChunk-&gt;RemoveEntity(GlobalCoord, *EntityData);&#10;  }&#10;  EntityToChunk.Remove(GlobalCoord);&#10;  OriginalVoxels.Remove(GlobalCoord);&#10;&#10;  // 청크가 비었으면 제거&#10;  if (OriginalVoxels.IsEmpty()) {&#10;    EntityChunks.Remove(OriginalChunk);&#10;    OriginalChunk-&gt;Destroy();&#10;    SplitVoxels.Add(GlobalCoord);&#10;    return;&#10;  }&#10;&#10;  // 나머지 엔티티들을 새로운 청크들로 분할&#10;  TSet&lt;FIntVector&gt; AllProcessedVoxels = ProcessedVoxels;&#10;  AllProcessedVoxels.Add(GlobalCoord);&#10;&#10;  // 기존 청크에서 모든 엔티티 제거&#10;  for (const FIntVector&amp; VoxelCoord : OriginalVoxels) {&#10;    if (const FVoxelEntityData* EntityData =&#10;        dynamic_cast&lt;const FVoxelEntityData*&gt;(DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;      OriginalChunk-&gt;RemoveEntity(VoxelCoord, *EntityData);&#10;    }&#10;    EntityToChunk.Remove(VoxelCoord);&#10;  }&#10;  EntityChunks.Remove(OriginalChunk);&#10;  OriginalChunk-&gt;Destroy();&#10;&#10;  // 연결된 그룹들로 새 청크 생성&#10;  TSet&lt;FIntVector&gt; VisitedForSplit;&#10;  for (const FIntVector&amp; VoxelCoord : OriginalVoxels) {&#10;    if (VisitedForSplit.Contains(VoxelCoord) || AllProcessedVoxels.Contains(VoxelCoord)) {&#10;      continue;&#10;    }&#10;&#10;    TSet&lt;FIntVector&gt; ChunkableVoxels;&#10;    if (GetChunkableEntityCoords(VoxelCoord, VisitedForSplit, ChunkableVoxels)) {&#10;      if (const FVoxelEntityData* EntityData =&#10;          dynamic_cast&lt;const FVoxelEntityData*&gt;(DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;        TObjectPtr&lt;AEntityChunkActor&gt; NewChunk = GetEntityChunk(*EntityData);&#10;&#10;        for (const FIntVector&amp; ChunkableVoxel : ChunkableVoxels) {&#10;          if (const FVoxelEntityData* VoxelEntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData*&gt;(DataManager-&gt;GetVoxelData(ChunkableVoxel))) {&#10;            NewChunk-&gt;AddEntity(ChunkableVoxel, *VoxelEntityData);&#10;            EntityToChunk.Add(ChunkableVoxel, NewChunk);&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  SplitVoxels = OriginalVoxels;&#10;  SplitVoxels.Add(GlobalCoord);&#10;}&#10;&#10;UEntityManager::UEntityManager() {&#10;  bWantsInitializeComponent = true;&#10;}&#10;&#10;TObjectPtr&lt;AEntityChunkActor&gt; UEntityManager::GetEntityChunk(&#10;    const FVoxelEntityData&amp; EntityData) {&#10;  const TObjectPtr&lt;const UVoxelEntityDataAsset&gt; EntityDataAsset =&#10;      EntityData.GetEntityDataAsset();&#10;&#10;  if (!EntityDataAsset) {&#10;    return nullptr;&#10;  }&#10;&#10;  const TObjectPtr&lt;UWorld&gt; World = GetWorld();&#10;  if (!World) {&#10;    return nullptr;&#10;  }&#10;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; NewEntityChunkActor;&#10;&#10;  if (EntityDataAsset-&gt;EntityChunkActorClass) {&#10;    NewEntityChunkActor = World-&gt;SpawnActor&lt;AEntityChunkActor&gt;(&#10;        EntityDataAsset-&gt;EntityChunkActorClass);&#10;  } else {&#10;    NewEntityChunkActor = World-&gt;SpawnActor&lt;AEntityChunkActor&gt;();&#10;  }&#10;&#10;  EntityChunks.Add(NewEntityChunkActor);&#10;&#10;  return NewEntityChunkActor;&#10;}&#10;&#10;void UEntityManager::UpdateEntityChunk(&#10;    const TObjectPtr&lt;AEntityChunkActor&gt;&amp; OriginalChunk) {&#10;  TArray&lt;FIntVector&gt; OriginalVoxels = OriginalChunk-&gt;GetEntities().Array();&#10;&#10;  for (const FIntVector&amp; VoxelCoord : OriginalVoxels) {&#10;    if (const FVoxelEntityData* EntityData =&#10;            dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;      OriginalChunk-&gt;RemoveEntity(VoxelCoord, *EntityData);&#10;    }&#10;    EntityToChunk.Remove(VoxelCoord);&#10;  }&#10;&#10;  EntityChunks.Remove(OriginalChunk);&#10;  OriginalChunk-&gt;Destroy();&#10;&#10;  TSet&lt;FIntVector&gt; VisitedVoxels;&#10;&#10;  for (const FIntVector&amp; VoxelCoord : OriginalVoxels) {&#10;    if (VisitedVoxels.Contains(VoxelCoord)) {&#10;      continue;&#10;    }&#10;&#10;    if (TSet&lt;FIntVector&gt; ChunkableVoxels;&#10;        GetChunkableEntityCoords(VoxelCoord, VisitedVoxels, ChunkableVoxels)) {&#10;      if (const FVoxelEntityData* EntityData =&#10;              dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                  DataManager-&gt;GetVoxelData(VoxelCoord))) {&#10;        TObjectPtr&lt;AEntityChunkActor&gt; NewChunk = GetEntityChunk(*EntityData);&#10;&#10;        for (const FIntVector&amp; ChunkableVoxel : ChunkableVoxels) {&#10;          if (const FVoxelEntityData* VoxelEntityData =&#10;                  dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;                      DataManager-&gt;GetVoxelData(ChunkableVoxel))) {&#10;            NewChunk-&gt;AddEntity(ChunkableVoxel, *VoxelEntityData);&#10;            EntityToChunk.Add(ChunkableVoxel, NewChunk);&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;bool UEntityManager::GetChunkableEntityCoords(&#10;    const FIntVector&amp; StartCoord, TSet&lt;FIntVector&gt;&amp; VisitedCoords,&#10;    TSet&lt;FIntVector&gt;&amp; ChunkableEntityCoords) const {&#10;  ChunkableEntityCoords.Reset();&#10;  TQueue&lt;FIntVector&gt; ToVisit;&#10;&#10;  const FVoxelEntityData* StartEntityData =&#10;      dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;          DataManager-&gt;GetVoxelData(StartCoord));&#10;&#10;  if (!StartEntityData) {&#10;    return false;&#10;  }&#10;&#10;  ToVisit.Enqueue(StartCoord);&#10;&#10;  while (!ToVisit.IsEmpty()) {&#10;    FIntVector CurrentCoord;&#10;    ToVisit.Dequeue(CurrentCoord);&#10;&#10;    if (VisitedCoords.Contains(CurrentCoord)) {&#10;      continue;&#10;    }&#10;&#10;    const FVoxelEntityData* CurrentEntityData =&#10;        dynamic_cast&lt;const FVoxelEntityData*&gt;(&#10;            DataManager-&gt;GetVoxelData(CurrentCoord));&#10;&#10;    if (!CurrentEntityData ||&#10;        !StartEntityData-&gt;IsChunkableWith(CurrentEntityData)) {&#10;      continue;&#10;    }&#10;&#10;    VisitedCoords.Add(CurrentCoord);&#10;    ChunkableEntityCoords.Add(CurrentCoord);&#10;&#10;    for (const FIntVector&amp; Offset : NeighborOffsets) {&#10;      if (const FIntVector NeighborCoord = CurrentCoord + Offset;&#10;          !VisitedCoords.Contains(NeighborCoord)) {&#10;        if (FVoxelEntityData::IsEntity(&#10;                DataManager-&gt;GetVoxelData(NeighborCoord))) {&#10;          ToVisit.Enqueue(NeighborCoord);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  return !ChunkableEntityCoords.IsEmpty();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Entity/Entity.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Entity/Entity.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Entity/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Entity/EntityChunk.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/EntityChunkComponent.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/EntityChunkComponent.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunkComponent.generated.h&quot;&#10;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS(Abstract, BlueprintType)&#10;class VOXEL_API UEntityChunkComponent : public UObject {&#10;  GENERATED_BODY()&#10;&#10;public:&#10;  virtual void OnEntityAdded(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {}&#10;  virtual void OnEntityRemoved(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {}&#10;  virtual void OnEntityModified(const FIntVector&amp; VoxelCoord, const FVoxelEntityData&amp; Data) {}&#10;  virtual void Tick(float DeltaTime) {}&#10;&#10;protected:&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UEntityChunk&gt; OwnerChunk;&#10;&#10;  friend class UEntityChunk;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Logic/EntityChunk.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Logic/EntityChunk.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityChunk.generated.h&quot;&#10;&#10;class UEntityManager;&#10;&#10;UCLASS()&#10;class VOXEL_API UEntityChunk : public UObject&#10;{&#10;&#9;GENERATED_BODY()&#10;&#10;public:&#10;&#9;void Initialize(UEntityManager* InManager);&#10;&#9;void Tick(float DeltaTime);&#10;&#10;&#9;void AddVoxel(const FIntVector&amp; VoxelCoord);&#10;&#9;void RemoveVoxel(const FIntVector&amp; VoxelCoord);&#10;&#9;void MergeWith(UEntityChunk* OtherChunk);&#10;&#10;&#9;const TSet&lt;FIntVector&gt;&amp; GetVoxels() const;&#10;&#9;bool IsEmpty() const;&#10;&#10;&#9;// 이 청크에 속한 모든 복셀의 맵을 업데이트합니다.&#10;&#9;void UpdateVoxelMap();&#10;&#10;private:&#10;&#9;UPROPERTY()&#10;&#9;TSet&lt;FIntVector&gt; ManagedVoxels;&#10;&#10;&#9;UPROPERTY()&#10;&#9;TObjectPtr&lt;UEntityManager&gt; EntityManager;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Managers/DataManager.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Managers/DataManager.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;DataAssets/VoxelVoidDataAsset.h&quot;&#10;#include &quot;Voxel/Public/VoxelChunk.h&quot;&#10;&#10;#include &quot;DataManager.generated.h&quot;&#10;&#10;class UVoxelBlockDataAsset;&#10;class UMeshManager;&#10;class UDebugManager;&#10;class UVoxelBorderDataAsset;&#10;class UVoxelVoidDataAsset;&#10;class UVoxelBaseDataAsset;&#10;class AVoxelChunkActor;&#10;class UEntityManager;&#10;&#10;UCLASS()&#10;&#10;class VOXEL_API UDataManager : public UActorComponent {&#10;  GENERATED_BODY()&#10;&#10; public:&#10;  static float GetSurfaceLevel() { return 0.f; }&#10;&#10;  FVoxelChunk* GetVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;&#10;  inline const FVoxelBaseData* GetVoxelData(const FIntVector&amp; GlobalCoord);&#10;&#10;  void ModifyVoxelData(const FIntVector&amp; GlobalCoord,&#10;                       const TFunction&lt;void(FVoxelBaseData*)&gt;&amp; Modifier,&#10;                       bool bAutoDebug = true);&#10;&#10;  void SetVoxelData(const FIntVector&amp; GlobalCoord, FVoxelBaseData* NewVoxelData,&#10;                    bool bAutoDebug = true);&#10;&#10;  int32 GetChunkSize() const { return ChunkSize; }&#10;&#10;  int32 GetVoxelSize() const { return VoxelSize; }&#10;&#10;  inline FVector GlobalToWorldCoord(const FIntVector&amp; GlobalCoord) const;&#10;  inline FIntVector GlobalToChunkCoord(const FIntVector&amp; GlobalCoord) const;&#10;  inline FIntVector GlobalToLocalCoord(const FIntVector&amp; GlobalCoord) const;&#10;&#10;  inline FIntVector WorldToGlobalCoord(const FVector&amp; WorldCoord) const;&#10;  inline FIntVector ChunkToGlobalCoord(const FIntVector&amp; ChunkCoord) const;&#10;  inline FIntVector LocalToGlobalCoord(const FIntVector&amp; LocalCoord,&#10;                                       const FIntVector&amp; ChunkCoord) const;&#10;&#10;  inline int32 LocalCoordToIndex(const FIntVector&amp; LocalCoord) const;&#10;  inline int32 GlobalCoordToIndex(const FIntVector&amp; GlobalCoord) const;&#10;&#10; private:&#10;  UDataManager();&#10;&#10;  virtual void InitializeComponent() override;&#10;&#10;  FVoxelChunk* LoadVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;  void UnloadVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  int32 ChunkSize = 16;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  int32 VoxelSize = 50;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TObjectPtr&lt;UVoxelBlockDataAsset&gt; VoxelDefaultBlockDataAsset;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TSubclassOf&lt;AVoxelChunkActor&gt; VoxelChunkActorClass;&#10;&#10;  TMap&lt;FIntVector, FVoxelChunk&gt; VoxelChunks;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UDebugManager&gt; DebugManager;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UMeshManager&gt; MeshManager;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UEntityManager&gt; EntityManager;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;DataAssets/VoxelVoidDataAsset.h&quot;&#10;#include &quot;Voxel/Public/VoxelChunk.h&quot;&#10;&#10;#include &quot;DataManager.generated.h&quot;&#10;&#10;class UVoxelBlockDataAsset;&#10;class UMeshManager;&#10;class UDebugManager;&#10;class UVoxelBorderDataAsset;&#10;class UVoxelVoidDataAsset;&#10;class UVoxelBaseDataAsset;&#10;class AVoxelChunkActor;&#10;class UEntityManager;&#10;&#10;UCLASS()&#10;&#10;class VOXEL_API UDataManager : public UActorComponent {&#10;  GENERATED_BODY()&#10;&#10; public:&#10;  static float GetSurfaceLevel() { return 0.f; }&#10;&#10;  FVoxelChunk* GetVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;&#10;  inline const FVoxelBaseData* GetVoxelData(const FIntVector&amp; GlobalCoord);&#10;&#10;  void ModifyVoxelData(const FIntVector&amp; GlobalCoord,&#10;                       const TFunction&lt;void(FVoxelBaseData*)&gt;&amp; Modifier,&#10;                       bool bAutoDebug = true);&#10;&#10;  void SetVoxelData(const FIntVector&amp; GlobalCoord, FVoxelBaseData* NewVoxelData,&#10;                    bool bAutoDebug = true);&#10;&#10;  int32 GetChunkSize() const { return ChunkSize; }&#10;&#10;  int32 GetVoxelSize() const { return VoxelSize; }&#10;&#10;  inline FVector GlobalToWorldCoord(const FIntVector&amp; GlobalCoord) const;&#10;  inline FIntVector GlobalToChunkCoord(const FIntVector&amp; GlobalCoord) const;&#10;  inline FIntVector GlobalToLocalCoord(const FIntVector&amp; GlobalCoord) const;&#10;&#10;  inline FIntVector WorldToGlobalCoord(const FVector&amp; WorldCoord) const;&#10;  inline FIntVector ChunkToGlobalCoord(const FIntVector&amp; ChunkCoord) const;&#10;  inline FIntVector LocalToGlobalCoord(const FIntVector&amp; LocalCoord,&#10;                                       const FIntVector&amp; ChunkCoord) const;&#10;&#10;  inline int32 LocalCoordToIndex(const FIntVector&amp; LocalCoord) const;&#10;  inline int32 GlobalCoordToIndex(const FIntVector&amp; GlobalCoord) const;&#10;&#10; private:&#10;  UDataManager();&#10;&#10;  virtual void InitializeComponent() override;&#10;&#10;  FVoxelChunk* LoadVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;  void UnloadVoxelChunk(const FIntVector&amp; ChunkCoord);&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  int32 ChunkSize = 16;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  int32 VoxelSize = 50;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TObjectPtr&lt;UVoxelBlockDataAsset&gt; VoxelDefaultBlockDataAsset;&#10;&#10;  UPROPERTY(EditDefaultsOnly)&#10;  TSubclassOf&lt;AVoxelChunkActor&gt; VoxelChunkActorClass;&#10;&#10;  TMap&lt;FIntVector, FVoxelChunk&gt; VoxelChunks;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UDebugManager&gt; DebugManager;&#10;&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;UMeshManager&gt; MeshManager;&#10;&#10; public:&#10;  UPROPERTY(VisibleAnywhere)&#10;  TObjectPtr&lt;class UEntityManager&gt; EntityManager;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Source/Voxel/Public/Managers/EntityManager.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Voxel/Public/Managers/EntityManager.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &quot;CoreMinimal.h&quot;&#10;#include &quot;EntityManager.generated.h&quot;&#10;&#10;class AEntityChunkActor;&#10;struct FVoxelEntityData;&#10;&#10;UCLASS()&#10;&#10;class VOXEL_API UEntityManager : public UActorComponent {&#10;  GENERATED_BODY()&#10;&#10;  const FIntVector NeighborOffsets[26] = {&#10;      FIntVector(1, 0, 0),   FIntVector(-1, 0, 0),  FIntVector(0, 1, 0),&#10;      FIntVector(0, -1, 0),  FIntVector(0, 0, 1),   FIntVector(0, 0, -1),&#10;&#10;      FIntVector(1, 1, 0),   FIntVector(1, -1, 0),  FIntVector(-1, 1, 0),&#10;      FIntVector(-1, -1, 0), FIntVector(1, 0, 1),   FIntVector(1, 0, -1),&#10;      FIntVector(-1, 0, 1),  FIntVector(-1, 0, -1), FIntVector(0, 1, 1),&#10;      FIntVector(0, 1, -1),  FIntVector(0, -1, 1),  FIntVector(0, -1, -1),&#10;&#10;      FIntVector(1, 1, 1),   FIntVector(1, 1, -1),  FIntVector(1, -1, 1),&#10;      FIntVector(1, -1, -1), FIntVector(-1, 1, 1),  FIntVector(-1, 1, -1),&#10;      FIntVector(-1, -1, 1), FIntVector(-1, -1, -1)};&#10;&#10; public:&#10;  void SetDirtyEntity(const FIntVector&amp; GlobalCoord);&#10;&#10;  void OnEntityModified(const FIntVector&amp; GlobalCoord,&#10;                        const FVoxelEntityData&amp; EntityData);&#10;&#10;  void FlushDirtyEntities();&#10;&#10; private:&#10;  UEntityManager();&#10;&#10;  virtual void InitializeComponent() override;&#10;&#10;  void UpdateEntityChunk(const TObjectPtr&lt;AEntityChunkActor&gt;&amp; OriginalChunk);&#10;  bool GetChunkableEntityCoords(const FIntVector&amp; StartCoord,&#10;                                TSet&lt;FIntVector&gt;&amp; VisitedCoords,&#10;                                TSet&lt;FIntVector&gt;&amp; ChunkableEntityCoords) const;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; GetEntityChunk(&#10;      const FVoxelEntityData&amp; EntityData);&#10;&#10;  UPROPERTY()&#10;  TObjectPtr&lt;class UDataManager&gt; DataManager;&#10;&#10;  TMap&lt;FIntVector, TObjectPtr&lt;AEntityChunkActor&gt;&gt; EntityToChunk;&#10;&#10;  TSet&lt;TObjectPtr&lt;AEntityChunkActor&gt;&gt; EntityChunks;&#10;&#10;  TSet&lt;FIntVector&gt; DirtyEntityVoxels;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#13;&#10;&#13;&#10;#include &quot;CoreMinimal.h&quot;&#13;&#10;#include &quot;EntityManager.generated.h&quot;&#13;&#10;&#13;&#10;class AEntityChunkActor;&#13;&#10;struct FVoxelEntityData;&#13;&#10;&#13;&#10;UCLASS()&#13;&#10;&#13;&#10;class VOXEL_API UEntityManager : public UActorComponent {&#13;&#10;  GENERATED_BODY()&#13;&#10;&#13;&#10;  const FIntVector NeighborOffsets[26] = {&#13;&#10;      FIntVector(1, 0, 0),   FIntVector(-1, 0, 0),  FIntVector(0, 1, 0),&#13;&#10;      FIntVector(0, -1, 0),  FIntVector(0, 0, 1),   FIntVector(0, 0, -1),&#13;&#10;&#13;&#10;      FIntVector(1, 1, 0),   FIntVector(1, -1, 0),  FIntVector(-1, 1, 0),&#13;&#10;      FIntVector(-1, -1, 0), FIntVector(1, 0, 1),   FIntVector(1, 0, -1),&#13;&#10;      FIntVector(-1, 0, 1),  FIntVector(-1, 0, -1), FIntVector(0, 1, 1),&#13;&#10;      FIntVector(0, 1, -1),  FIntVector(0, -1, 1),  FIntVector(0, -1, -1),&#13;&#10;&#13;&#10;      FIntVector(1, 1, 1),   FIntVector(1, 1, -1),  FIntVector(1, -1, 1),&#13;&#10;      FIntVector(1, -1, -1), FIntVector(-1, 1, 1),  FIntVector(-1, 1, -1),&#13;&#10;      FIntVector(-1, -1, 1), FIntVector(-1, -1, -1)};&#13;&#10;&#13;&#10; public:&#13;&#10;  void SetDirtyEntity(const FIntVector&amp; GlobalCoord);&#13;&#10;&#13;&#10;  void OnEntityModified(const FIntVector&amp; GlobalCoord,&#13;&#10;                        const FVoxelEntityData&amp; EntityData);&#13;&#10;&#13;&#10;  void FlushDirtyEntities();&#13;&#10;&#13;&#10; private:&#13;&#10;  UEntityManager();&#13;&#10;&#13;&#10;  virtual void InitializeComponent() override;&#13;&#10;&#13;&#10;  void PerformEntityMerge(const FIntVector&amp; GlobalCoord, &#13;&#10;                         const FVoxelEntityData&amp; EntityData,&#13;&#10;                         const TSet&lt;FIntVector&gt;&amp; ProcessedVoxels,&#13;&#10;                         TSet&lt;FIntVector&gt;&amp; MergedVoxels);&#13;&#10;                         &#13;&#10;  void PerformEntitySplit(const FIntVector&amp; GlobalCoord,&#13;&#10;                         const TSet&lt;FIntVector&gt;&amp; ProcessedVoxels,&#13;&#10;                         TSet&lt;FIntVector&gt;&amp; SplitVoxels);&#13;&#10;&#13;&#10;  void UpdateEntityChunk(const TObjectPtr&lt;AEntityChunkActor&gt;&amp; OriginalChunk);&#13;&#10;  bool GetChunkableEntityCoords(const FIntVector&amp; StartCoord,&#13;&#10;                                TSet&lt;FIntVector&gt;&amp; VisitedCoords,&#13;&#10;                                TSet&lt;FIntVector&gt;&amp; ChunkableEntityCoords) const;&#13;&#10;  TObjectPtr&lt;AEntityChunkActor&gt; GetEntityChunk(&#13;&#10;      const FVoxelEntityData&amp; EntityData);&#13;&#10;&#13;&#10;  UPROPERTY()&#13;&#10;  TObjectPtr&lt;class UDataManager&gt; DataManager;&#13;&#10;&#13;&#10;  TMap&lt;FIntVector, TObjectPtr&lt;AEntityChunkActor&gt;&gt; EntityToChunk;&#13;&#10;&#13;&#10;  TSet&lt;TObjectPtr&lt;AEntityChunkActor&gt;&gt; EntityChunks;&#13;&#10;&#13;&#10;  TSet&lt;FIntVector&gt; DirtyEntityVoxels;&#13;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>